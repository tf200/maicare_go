// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: contract.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createContract = `-- name: CreateContract :one
INSERT INTO contract (
    type_id,
    start_date,
    end_date,
    reminder_period,
    tax,
    price,
    price_frequency,
    hours,
    hours_type,
    care_name,
    care_type,
    client_id,
    sender_id,
    attachment_ids,
    financing_act,
    financing_option,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING id, type_id, status, start_date, end_date, reminder_period, tax, price, price_frequency, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated, created
`

type CreateContractParams struct {
	TypeID          *int64             `json:"type_id"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod  int32              `json:"reminder_period"`
	Tax             *int32             `json:"tax"`
	Price           float64            `json:"price"`
	PriceFrequency  string             `json:"price_frequency"`
	Hours           *int32             `json:"hours"`
	HoursType       string             `json:"hours_type"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	ClientID        int64              `json:"client_id"`
	SenderID        *int64             `json:"sender_id"`
	AttachmentIds   []uuid.UUID        `json:"attachment_ids"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
	Status          string             `json:"status"`
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, createContract,
		arg.TypeID,
		arg.StartDate,
		arg.EndDate,
		arg.ReminderPeriod,
		arg.Tax,
		arg.Price,
		arg.PriceFrequency,
		arg.Hours,
		arg.HoursType,
		arg.CareName,
		arg.CareType,
		arg.ClientID,
		arg.SenderID,
		arg.AttachmentIds,
		arg.FinancingAct,
		arg.FinancingOption,
		arg.Status,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.ReminderPeriod,
		&i.Tax,
		&i.Price,
		&i.PriceFrequency,
		&i.Hours,
		&i.HoursType,
		&i.CareName,
		&i.CareType,
		&i.ClientID,
		&i.SenderID,
		&i.AttachmentIds,
		&i.FinancingAct,
		&i.FinancingOption,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.Updated,
		&i.Created,
	)
	return i, err
}

const createContractType = `-- name: CreateContractType :one
INSERT INTO contract_type (name)
VALUES
    ($1)
RETURNING id, name
`

func (q *Queries) CreateContractType(ctx context.Context, name string) (ContractType, error) {
	row := q.db.QueryRow(ctx, createContractType, name)
	var i ContractType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteContractType = `-- name: DeleteContractType :exec
DELETE FROM contract_type
WHERE id = $1
`

func (q *Queries) DeleteContractType(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteContractType, id)
	return err
}

const getClientContract = `-- name: GetClientContract :one
SELECT id, type_id, status, start_date, end_date, reminder_period, tax, price, price_frequency, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated, created FROM contract
WHERE id = $1
limit 1
`

func (q *Queries) GetClientContract(ctx context.Context, id int64) (Contract, error) {
	row := q.db.QueryRow(ctx, getClientContract, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.ReminderPeriod,
		&i.Tax,
		&i.Price,
		&i.PriceFrequency,
		&i.Hours,
		&i.HoursType,
		&i.CareName,
		&i.CareType,
		&i.ClientID,
		&i.SenderID,
		&i.AttachmentIds,
		&i.FinancingAct,
		&i.FinancingOption,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.Updated,
		&i.Created,
	)
	return i, err
}

const getSenderContracts = `-- name: GetSenderContracts :many
SELECT id, type_id, status, start_date, end_date, reminder_period, tax, price, price_frequency, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated, created FROM contract
WHERE sender_id = $1
`

func (q *Queries) GetSenderContracts(ctx context.Context, senderID *int64) ([]Contract, error) {
	rows, err := q.db.Query(ctx, getSenderContracts, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.ReminderPeriod,
			&i.Tax,
			&i.Price,
			&i.PriceFrequency,
			&i.Hours,
			&i.HoursType,
			&i.CareName,
			&i.CareType,
			&i.ClientID,
			&i.SenderID,
			&i.AttachmentIds,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.DepartureReason,
			&i.DepartureReport,
			&i.Updated,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientContracts = `-- name: ListClientContracts :many
WITH client_contracts AS (
    SELECT id, type_id, status, start_date, end_date, reminder_period, tax, price, price_frequency, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated, created FROM contract
    WHERE client_id = $1
)
SELECT
    (SELECT COUNT(*) FROM client_contracts) AS total_count,
    id, type_id, status, start_date, end_date, reminder_period, tax, price, price_frequency, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated, created
FROM client_contracts
ORDER BY created DESC
LIMIT $2
OFFSET $3
`

type ListClientContractsParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientContractsRow struct {
	TotalCount      int64              `json:"total_count"`
	ID              int64              `json:"id"`
	TypeID          *int64             `json:"type_id"`
	Status          string             `json:"status"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod  int32              `json:"reminder_period"`
	Tax             *int32             `json:"tax"`
	Price           float64            `json:"price"`
	PriceFrequency  string             `json:"price_frequency"`
	Hours           *int32             `json:"hours"`
	HoursType       string             `json:"hours_type"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	ClientID        int64              `json:"client_id"`
	SenderID        *int64             `json:"sender_id"`
	AttachmentIds   []uuid.UUID        `json:"attachment_ids"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
	DepartureReason *string            `json:"departure_reason"`
	DepartureReport *string            `json:"departure_report"`
	Updated         pgtype.Timestamptz `json:"updated"`
	Created         pgtype.Timestamptz `json:"created"`
}

func (q *Queries) ListClientContracts(ctx context.Context, arg ListClientContractsParams) ([]ListClientContractsRow, error) {
	rows, err := q.db.Query(ctx, listClientContracts, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientContractsRow
	for rows.Next() {
		var i ListClientContractsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.ReminderPeriod,
			&i.Tax,
			&i.Price,
			&i.PriceFrequency,
			&i.Hours,
			&i.HoursType,
			&i.CareName,
			&i.CareType,
			&i.ClientID,
			&i.SenderID,
			&i.AttachmentIds,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.DepartureReason,
			&i.DepartureReport,
			&i.Updated,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContractTypes = `-- name: ListContractTypes :many
SELECT id, name FROM contract_type
`

func (q *Queries) ListContractTypes(ctx context.Context) ([]ContractType, error) {
	rows, err := q.db.Query(ctx, listContractTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContractType
	for rows.Next() {
		var i ContractType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContracts = `-- name: ListContracts :many
WITH filtered_contracts AS (
    SELECT
        c.id,
        c.status,
        c.start_date,
        c.end_date,
        c.price,
        c.price_frequency,
        c.care_name,
        c.care_type,
        c.financing_act,
        c.financing_option,
        c.created,
        s.name AS sender_name,
        cd.first_name AS client_first_name,
        cd.last_name AS client_last_name
    FROM
        contract c
    LEFT JOIN
        sender s ON c.sender_id = s.id
    JOIN
        client_details cd ON c.client_id = cd.id
    WHERE
        ($3::varchar IS NULL OR 
            s.name ILIKE '%' || $3 || '%' OR
            cd.first_name ILIKE '%' || $3 || '%' OR
            cd.last_name ILIKE '%' || $3 || '%')
    AND
        ($4::varchar[] IS NULL OR c.status = ANY($4))
    AND
        ($5::varchar[] IS NULL OR c.care_type = ANY($5))
    AND
        ($6::varchar[] IS NULL OR c.financing_act = ANY($6))
    AND
        ($7::varchar[] IS NULL OR c.financing_option = ANY($7))
)
SELECT
    (SELECT COUNT(*) FROM filtered_contracts) AS total_count,
    id, status, start_date, end_date, price, price_frequency, care_name, care_type, financing_act, financing_option, created, sender_name, client_first_name, client_last_name
FROM
    filtered_contracts
ORDER BY
    created DESC
LIMIT $1
OFFSET $2
`

type ListContractsParams struct {
	Limit           int32    `json:"limit"`
	Offset          int32    `json:"offset"`
	Search          *string  `json:"search"`
	Status          []string `json:"status"`
	CareType        []string `json:"care_type"`
	FinancingAct    []string `json:"financing_act"`
	FinancingOption []string `json:"financing_option"`
}

type ListContractsRow struct {
	TotalCount      int64              `json:"total_count"`
	ID              int64              `json:"id"`
	Status          string             `json:"status"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	Price           float64            `json:"price"`
	PriceFrequency  string             `json:"price_frequency"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
	Created         pgtype.Timestamptz `json:"created"`
	SenderName      *string            `json:"sender_name"`
	ClientFirstName string             `json:"client_first_name"`
	ClientLastName  string             `json:"client_last_name"`
}

func (q *Queries) ListContracts(ctx context.Context, arg ListContractsParams) ([]ListContractsRow, error) {
	rows, err := q.db.Query(ctx, listContracts,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.CareType,
		arg.FinancingAct,
		arg.FinancingOption,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContractsRow
	for rows.Next() {
		var i ListContractsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.Price,
			&i.PriceFrequency,
			&i.CareName,
			&i.CareType,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.Created,
			&i.SenderName,
			&i.ClientFirstName,
			&i.ClientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
