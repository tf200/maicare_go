// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contract.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createContract = `-- name: CreateContract :one
INSERT INTO contract (
    type_id,
    start_date,
    end_date,
    reminder_period,
    VAT,
    price,
    price_time_unit,
    hours,
    hours_type,
    care_name,
    care_type,
    client_id,
    sender_id,
    attachment_ids,
    financing_act,
    financing_option
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
RETURNING id, type_id, status, start_date, end_date, reminder_period, vat, price, price_time_unit, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated_at, created_at
`

type CreateContractParams struct {
	TypeID          *int64             `json:"type_id"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod  int32              `json:"reminder_period"`
	Vat             *int32             `json:"vat"`
	Price           float64            `json:"price"`
	PriceTimeUnit   string             `json:"price_time_unit"`
	Hours           *float64           `json:"hours"`
	HoursType       *string            `json:"hours_type"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	ClientID        int64              `json:"client_id"`
	SenderID        *int64             `json:"sender_id"`
	AttachmentIds   []uuid.UUID        `json:"attachment_ids"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, createContract,
		arg.TypeID,
		arg.StartDate,
		arg.EndDate,
		arg.ReminderPeriod,
		arg.Vat,
		arg.Price,
		arg.PriceTimeUnit,
		arg.Hours,
		arg.HoursType,
		arg.CareName,
		arg.CareType,
		arg.ClientID,
		arg.SenderID,
		arg.AttachmentIds,
		arg.FinancingAct,
		arg.FinancingOption,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.ReminderPeriod,
		&i.Vat,
		&i.Price,
		&i.PriceTimeUnit,
		&i.Hours,
		&i.HoursType,
		&i.CareName,
		&i.CareType,
		&i.ClientID,
		&i.SenderID,
		&i.AttachmentIds,
		&i.FinancingAct,
		&i.FinancingOption,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createContractReminder = `-- name: CreateContractReminder :one
INSERT INTO contract_reminder (
    contract_id,
    reminder_sent_at,
    reminder_type
) VALUES (
    $1, $2,
    CASE WHEN NOT EXISTS (
        SELECT 1 FROM contract_reminder
        WHERE contract_id = $1
        AND reminder_sent_at IS NOT NULL
    ) THEN 'initial' 
    ELSE 'follow_up' END
)
RETURNING id, contract_id, reminder_sent_at, reminder_type
`

type CreateContractReminderParams struct {
	ContractID     int64              `json:"contract_id"`
	ReminderSentAt pgtype.Timestamptz `json:"reminder_sent_at"`
}

func (q *Queries) CreateContractReminder(ctx context.Context, arg CreateContractReminderParams) (ContractReminder, error) {
	row := q.db.QueryRow(ctx, createContractReminder, arg.ContractID, arg.ReminderSentAt)
	var i ContractReminder
	err := row.Scan(
		&i.ID,
		&i.ContractID,
		&i.ReminderSentAt,
		&i.ReminderType,
	)
	return i, err
}

const createContractType = `-- name: CreateContractType :one
INSERT INTO contract_type (name)
VALUES
    ($1)
RETURNING id, name
`

func (q *Queries) CreateContractType(ctx context.Context, name string) (ContractType, error) {
	row := q.db.QueryRow(ctx, createContractType, name)
	var i ContractType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteContractType = `-- name: DeleteContractType :exec
DELETE FROM contract_type
WHERE id = $1
`

func (q *Queries) DeleteContractType(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteContractType, id)
	return err
}

const getClientContract = `-- name: GetClientContract :one
SELECT c.id, c.type_id, c.status, c.start_date, c.end_date, c.reminder_period, c.vat, c.price, c.price_time_unit, c.hours, c.hours_type, c.care_name, c.care_type, c.client_id, c.sender_id, c.attachment_ids, c.financing_act, c.financing_option, c.departure_reason, c.departure_report, c.updated_at, c.created_at,
        ct.name AS contract_type_name,
        cd.first_name AS client_first_name,
        cd.last_name AS client_last_name,
        s.name AS sender_name
FROM contract c
JOIN contract_type ct ON c.type_id = ct.id
JOIN client_details cd ON c.client_id = cd.id
LEFT JOIN sender s ON c.sender_id = s.id
WHERE c.id = $1
limit 1
`

type GetClientContractRow struct {
	ID               int64              `json:"id"`
	TypeID           *int64             `json:"type_id"`
	Status           string             `json:"status"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	EndDate          pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod   int32              `json:"reminder_period"`
	Vat              *int32             `json:"vat"`
	Price            float64            `json:"price"`
	PriceTimeUnit    string             `json:"price_time_unit"`
	Hours            *float64           `json:"hours"`
	HoursType        *string            `json:"hours_type"`
	CareName         string             `json:"care_name"`
	CareType         string             `json:"care_type"`
	ClientID         int64              `json:"client_id"`
	SenderID         *int64             `json:"sender_id"`
	AttachmentIds    []uuid.UUID        `json:"attachment_ids"`
	FinancingAct     string             `json:"financing_act"`
	FinancingOption  string             `json:"financing_option"`
	DepartureReason  *string            `json:"departure_reason"`
	DepartureReport  *string            `json:"departure_report"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ContractTypeName string             `json:"contract_type_name"`
	ClientFirstName  string             `json:"client_first_name"`
	ClientLastName   string             `json:"client_last_name"`
	SenderName       *string            `json:"sender_name"`
}

func (q *Queries) GetClientContract(ctx context.Context, id int64) (GetClientContractRow, error) {
	row := q.db.QueryRow(ctx, getClientContract, id)
	var i GetClientContractRow
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.ReminderPeriod,
		&i.Vat,
		&i.Price,
		&i.PriceTimeUnit,
		&i.Hours,
		&i.HoursType,
		&i.CareName,
		&i.CareType,
		&i.ClientID,
		&i.SenderID,
		&i.AttachmentIds,
		&i.FinancingAct,
		&i.FinancingOption,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.ContractTypeName,
		&i.ClientFirstName,
		&i.ClientLastName,
		&i.SenderName,
	)
	return i, err
}

const getSenderContracts = `-- name: GetSenderContracts :many
SELECT id, type_id, status, start_date, end_date, reminder_period, vat, price, price_time_unit, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated_at, created_at FROM contract
WHERE sender_id = $1
`

func (q *Queries) GetSenderContracts(ctx context.Context, senderID *int64) ([]Contract, error) {
	rows, err := q.db.Query(ctx, getSenderContracts, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contract
	for rows.Next() {
		var i Contract
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.ReminderPeriod,
			&i.Vat,
			&i.Price,
			&i.PriceTimeUnit,
			&i.Hours,
			&i.HoursType,
			&i.CareName,
			&i.CareType,
			&i.ClientID,
			&i.SenderID,
			&i.AttachmentIds,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.DepartureReason,
			&i.DepartureReport,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientContracts = `-- name: ListClientContracts :many
WITH client_contracts AS (
    SELECT id, type_id, status, start_date, end_date, reminder_period, vat, price, price_time_unit, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated_at, created_at FROM contract
    WHERE client_id = $1
)
SELECT
    (SELECT COUNT(*) FROM client_contracts) AS total_count,
    id, type_id, status, start_date, end_date, reminder_period, vat, price, price_time_unit, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated_at, created_at
FROM client_contracts
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListClientContractsParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientContractsRow struct {
	TotalCount      int64              `json:"total_count"`
	ID              int64              `json:"id"`
	TypeID          *int64             `json:"type_id"`
	Status          string             `json:"status"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod  int32              `json:"reminder_period"`
	Vat             *int32             `json:"vat"`
	Price           float64            `json:"price"`
	PriceTimeUnit   string             `json:"price_time_unit"`
	Hours           *float64           `json:"hours"`
	HoursType       *string            `json:"hours_type"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	ClientID        int64              `json:"client_id"`
	SenderID        *int64             `json:"sender_id"`
	AttachmentIds   []uuid.UUID        `json:"attachment_ids"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
	DepartureReason *string            `json:"departure_reason"`
	DepartureReport *string            `json:"departure_report"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListClientContracts(ctx context.Context, arg ListClientContractsParams) ([]ListClientContractsRow, error) {
	rows, err := q.db.Query(ctx, listClientContracts, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientContractsRow
	for rows.Next() {
		var i ListClientContractsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.ReminderPeriod,
			&i.Vat,
			&i.Price,
			&i.PriceTimeUnit,
			&i.Hours,
			&i.HoursType,
			&i.CareName,
			&i.CareType,
			&i.ClientID,
			&i.SenderID,
			&i.AttachmentIds,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.DepartureReason,
			&i.DepartureReport,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContractTypes = `-- name: ListContractTypes :many
SELECT id, name FROM contract_type
`

func (q *Queries) ListContractTypes(ctx context.Context) ([]ContractType, error) {
	rows, err := q.db.Query(ctx, listContractTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContractType
	for rows.Next() {
		var i ContractType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContracts = `-- name: ListContracts :many
WITH filtered_contracts AS (
    SELECT
        c.id,
        c.status,
        c.start_date,
        c.end_date,
        c.price,
        c.price_time_unit,
        c.care_name,
        c.care_type,
        c.financing_act,
        c.financing_option,
        c.created_at,
        s.name AS sender_name,
        cd.id AS client_id,
        cd.sender_id AS sender_id,
        cd.first_name AS client_first_name,
        cd.last_name AS client_last_name
    FROM
        contract c
    LEFT JOIN
        sender s ON c.sender_id = s.id
    JOIN
        client_details cd ON c.client_id = cd.id
    WHERE
        ($3::varchar IS NULL OR 
            s.name ILIKE '%' || $3 || '%' OR
            cd.first_name ILIKE '%' || $3 || '%' OR
            cd.last_name ILIKE '%' || $3 || '%')
    AND
        ($4::varchar[] IS NULL OR c.status = ANY($4))
    AND
        ($5::varchar[] IS NULL OR c.care_type = ANY($5))
    AND
        ($6::varchar[] IS NULL OR c.financing_act = ANY($6))
    AND
        ($7::varchar[] IS NULL OR c.financing_option = ANY($7))
)
SELECT
    (SELECT COUNT(*) FROM filtered_contracts) AS total_count,
    id, status, start_date, end_date, price, price_time_unit, care_name, care_type, financing_act, financing_option, created_at, sender_name, client_id, sender_id, client_first_name, client_last_name
FROM
    filtered_contracts
ORDER BY
    created_at DESC
LIMIT $1
OFFSET $2
`

type ListContractsParams struct {
	Limit           int32    `json:"limit"`
	Offset          int32    `json:"offset"`
	Search          *string  `json:"search"`
	Status          []string `json:"status"`
	CareType        []string `json:"care_type"`
	FinancingAct    []string `json:"financing_act"`
	FinancingOption []string `json:"financing_option"`
}

type ListContractsRow struct {
	TotalCount      int64              `json:"total_count"`
	ID              int64              `json:"id"`
	Status          string             `json:"status"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	Price           float64            `json:"price"`
	PriceTimeUnit   string             `json:"price_time_unit"`
	CareName        string             `json:"care_name"`
	CareType        string             `json:"care_type"`
	FinancingAct    string             `json:"financing_act"`
	FinancingOption string             `json:"financing_option"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	SenderName      *string            `json:"sender_name"`
	ClientID        int64              `json:"client_id"`
	SenderID        *int64             `json:"sender_id"`
	ClientFirstName string             `json:"client_first_name"`
	ClientLastName  string             `json:"client_last_name"`
}

func (q *Queries) ListContracts(ctx context.Context, arg ListContractsParams) ([]ListContractsRow, error) {
	rows, err := q.db.Query(ctx, listContracts,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.Status,
		arg.CareType,
		arg.FinancingAct,
		arg.FinancingOption,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContractsRow
	for rows.Next() {
		var i ListContractsRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.Price,
			&i.PriceTimeUnit,
			&i.CareName,
			&i.CareType,
			&i.FinancingAct,
			&i.FinancingOption,
			&i.CreatedAt,
			&i.SenderName,
			&i.ClientID,
			&i.SenderID,
			&i.ClientFirstName,
			&i.ClientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContractsTobeReminded = `-- name: ListContractsTobeReminded :many
SELECT c.id,
       c.care_name,
       c.client_id,
       c.start_date,
       c.end_date,
       c.reminder_period,
       c.care_type,
       cd.id AS client_id,
         cd.first_name AS client_first_name,
         cd.last_name AS client_last_name,

       (c.end_date - INTERVAL '1 day' * c.reminder_period) AS reminder_date,

       COALESCE(MAX(cr.reminder_sent_at), '1970-01-01'::TIMESTAMPTZ)::TIMESTAMPTZ AS last_reminder_date

FROM contract c
JOIN client_details cd ON c.client_id = cd.id
LEFT JOIN contract_reminder cr ON c.id = cr.contract_id
    AND cr.reminder_sent_at IS NOT NULL

WHERE 
    c.status = 'approved'


    AND CURRENT_DATE >= (c.end_date - INTERVAL '1 day' * c.reminder_period)::date
    AND c.end_date > CURRENT_TIMESTAMP

GROUP BY c.id, c.care_name, c.client_id, c.end_date, c.reminder_period
HAVING 
    (MAX(cr.reminder_sent_at) IS NULL OR
      MAX(cr.reminder_sent_at) < CURRENT_TIMESTAMP - INTERVAL '7 days')
ORDER BY c.end_date ASC
`

type ListContractsTobeRemindedRow struct {
	ID               int64              `json:"id"`
	CareName         string             `json:"care_name"`
	ClientID         int64              `json:"client_id"`
	StartDate        pgtype.Timestamptz `json:"start_date"`
	EndDate          pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod   int32              `json:"reminder_period"`
	CareType         string             `json:"care_type"`
	ClientID_2       int64              `json:"client_id_2"`
	ClientFirstName  string             `json:"client_first_name"`
	ClientLastName   string             `json:"client_last_name"`
	ReminderDate     int32              `json:"reminder_date"`
	LastReminderDate pgtype.Timestamptz `json:"last_reminder_date"`
}

func (q *Queries) ListContractsTobeReminded(ctx context.Context) ([]ListContractsTobeRemindedRow, error) {
	rows, err := q.db.Query(ctx, listContractsTobeReminded)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContractsTobeRemindedRow
	for rows.Next() {
		var i ListContractsTobeRemindedRow
		if err := rows.Scan(
			&i.ID,
			&i.CareName,
			&i.ClientID,
			&i.StartDate,
			&i.EndDate,
			&i.ReminderPeriod,
			&i.CareType,
			&i.ClientID_2,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.ReminderDate,
			&i.LastReminderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContract = `-- name: UpdateContract :one
UPDATE contract
SET 
    type_id = COALESCE($2, type_id),
    start_date = COALESCE($3, start_date),
    end_date = COALESCE($4, end_date),
    reminder_period = COALESCE($5, reminder_period),
    VAT = COALESCE($6, VAT),
    price = COALESCE($7, price),
    price_time_unit = COALESCE($8, price_time_unit),
    hours = COALESCE($9, hours),
    hours_type = COALESCE($10, hours_type),
    care_name = COALESCE($11, care_name),
    care_type = COALESCE($12, care_type),
    sender_id = COALESCE($13, sender_id),
    attachment_ids = COALESCE($14, attachment_ids),
    financing_act = COALESCE($15, financing_act),
    financing_option = COALESCE($16, financing_option),
    status = COALESCE($17, status)
WHERE id = $1
RETURNING id, type_id, status, start_date, end_date, reminder_period, vat, price, price_time_unit, hours, hours_type, care_name, care_type, client_id, sender_id, attachment_ids, financing_act, financing_option, departure_reason, departure_report, updated_at, created_at
`

type UpdateContractParams struct {
	ID              int64              `json:"id"`
	TypeID          *int64             `json:"type_id"`
	StartDate       pgtype.Timestamptz `json:"start_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	ReminderPeriod  *int32             `json:"reminder_period"`
	VAT             *int32             `json:"VAT"`
	Price           *float64           `json:"price"`
	PriceTimeUnit   *string            `json:"price_time_unit"`
	Hours           *float64           `json:"hours"`
	HoursType       *string            `json:"hours_type"`
	CareName        *string            `json:"care_name"`
	CareType        *string            `json:"care_type"`
	SenderID        *int64             `json:"sender_id"`
	AttachmentIds   []uuid.UUID        `json:"attachment_ids"`
	FinancingAct    *string            `json:"financing_act"`
	FinancingOption *string            `json:"financing_option"`
	Status          *string            `json:"status"`
}

func (q *Queries) UpdateContract(ctx context.Context, arg UpdateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, updateContract,
		arg.ID,
		arg.TypeID,
		arg.StartDate,
		arg.EndDate,
		arg.ReminderPeriod,
		arg.VAT,
		arg.Price,
		arg.PriceTimeUnit,
		arg.Hours,
		arg.HoursType,
		arg.CareName,
		arg.CareType,
		arg.SenderID,
		arg.AttachmentIds,
		arg.FinancingAct,
		arg.FinancingOption,
		arg.Status,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.ReminderPeriod,
		&i.Vat,
		&i.Price,
		&i.PriceTimeUnit,
		&i.Hours,
		&i.HoursType,
		&i.CareName,
		&i.CareType,
		&i.ClientID,
		&i.SenderID,
		&i.AttachmentIds,
		&i.FinancingAct,
		&i.FinancingOption,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
