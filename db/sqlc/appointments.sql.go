// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAppointmentClient = `-- name: AddAppointmentClient :exec
INSERT INTO appointment_clients (
    appointment_id,
    client_id       
) VALUES (
    $1, $2
)
`

type AddAppointmentClientParams struct {
	AppointmentID int64 `json:"appointment_id"`
	ClientID      int64 `json:"client_id"`
}

func (q *Queries) AddAppointmentClient(ctx context.Context, arg AddAppointmentClientParams) error {
	_, err := q.db.Exec(ctx, addAppointmentClient, arg.AppointmentID, arg.ClientID)
	return err
}

const addAppointmentParticipant = `-- name: AddAppointmentParticipant :exec
INSERT INTO appointment_participants (
    appointment_id,
    employee_id     
) VALUES (
    $1, $2
)
`

type AddAppointmentParticipantParams struct {
	AppointmentID int64 `json:"appointment_id"`
	EmployeeID    int64 `json:"employee_id"`
}

func (q *Queries) AddAppointmentParticipant(ctx context.Context, arg AddAppointmentParticipantParams) error {
	_, err := q.db.Exec(ctx, addAppointmentParticipant, arg.AppointmentID, arg.EmployeeID)
	return err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description,          
    status,               
    recurrence_type,      
    recurrence_interval,  
    recurrence_end_date   
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, creator_employee_id, start_time, end_time, location, description, status, recurrence_type, recurrence_interval, recurrence_end_date, confirmed_by_employee_id, confirmed_at, created_at, updated_at
`

type CreateAppointmentParams struct {
	CreatorEmployeeID  int64            `json:"creator_employee_id"`
	StartTime          pgtype.Timestamp `json:"start_time"`
	EndTime            pgtype.Timestamp `json:"end_time"`
	Location           *string          `json:"location"`
	Description        *string          `json:"description"`
	Status             string           `json:"status"`
	RecurrenceType     *string          `json:"recurrence_type"`
	RecurrenceInterval *int32           `json:"recurrence_interval"`
	RecurrenceEndDate  pgtype.Date      `json:"recurrence_end_date"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
		arg.Status,
		arg.RecurrenceType,
		arg.RecurrenceInterval,
		arg.RecurrenceEndDate,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.Status,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.ConfirmedByEmployeeID,
		&i.ConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppointmentTemplatesForEmployee = `-- name: GetAppointmentTemplatesForEmployee :many
SELECT
    a.id,
    a.creator_employee_id,
    a.start_time,
    a.end_time,
    a.location,
    a.description,
    a.status,
    a.recurrence_type,
    a.recurrence_interval,
    a.recurrence_end_date
FROM
    appointments a
LEFT JOIN appointment_participants ap ON a.id = ap.appointment_id
WHERE
    (a.creator_employee_id = $1 OR ap.employee_id = $1)
AND a.status = ANY($4::VARCHAR[])
AND a.start_time >= $3
AND (a.recurrence_end_date IS NULL OR a.recurrence_end_date >= $2)
GROUP BY a.id
`

type GetAppointmentTemplatesForEmployeeParams struct {
	CreatorEmployeeID int64            `json:"creator_employee_id"`
	RecurrenceEndDate pgtype.Date      `json:"recurrence_end_date"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	Column4           []string         `json:"column_4"`
}

type GetAppointmentTemplatesForEmployeeRow struct {
	ID                 int64            `json:"id"`
	CreatorEmployeeID  int64            `json:"creator_employee_id"`
	StartTime          pgtype.Timestamp `json:"start_time"`
	EndTime            pgtype.Timestamp `json:"end_time"`
	Location           *string          `json:"location"`
	Description        *string          `json:"description"`
	Status             string           `json:"status"`
	RecurrenceType     *string          `json:"recurrence_type"`
	RecurrenceInterval *int32           `json:"recurrence_interval"`
	RecurrenceEndDate  pgtype.Date      `json:"recurrence_end_date"`
}

func (q *Queries) GetAppointmentTemplatesForEmployee(ctx context.Context, arg GetAppointmentTemplatesForEmployeeParams) ([]GetAppointmentTemplatesForEmployeeRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentTemplatesForEmployee,
		arg.CreatorEmployeeID,
		arg.RecurrenceEndDate,
		arg.StartTime,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppointmentTemplatesForEmployeeRow
	for rows.Next() {
		var i GetAppointmentTemplatesForEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatorEmployeeID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.RecurrenceType,
			&i.RecurrenceInterval,
			&i.RecurrenceEndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsForAppointments = `-- name: GetClientsForAppointments :many
SELECT
    ac.appointment_id,
    ac.client_id,
    c.first_name AS client_first_name,
    c.last_name AS client_last_name 
FROM appointment_clients ac
JOIN client_details c ON ac.client_id = c.client_id -- Ensure 'clients' table and 'name' column exist
WHERE ac.appointment_id = ANY($1::INT[])
`

type GetClientsForAppointmentsRow struct {
	AppointmentID   int64  `json:"appointment_id"`
	ClientID        int64  `json:"client_id"`
	ClientFirstName string `json:"client_first_name"`
	ClientLastName  string `json:"client_last_name"`
}

func (q *Queries) GetClientsForAppointments(ctx context.Context, dollar_1 []int32) ([]GetClientsForAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, getClientsForAppointments, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsForAppointmentsRow
	for rows.Next() {
		var i GetClientsForAppointmentsRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.ClientID,
			&i.ClientFirstName,
			&i.ClientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantsForAppointments = `-- name: GetParticipantsForAppointments :many
SELECT
    ap.appointment_id,
    ap.employee_id,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name -- Join to get names for the frontend
    -- Include other employee details if needed by the frontend
FROM appointment_participants ap
JOIN employee_profile e ON ap.employee_id = e.employee_id -- Ensure 'employees' table and 'name' column exist
WHERE ap.appointment_id = ANY($1::INT[])
`

type GetParticipantsForAppointmentsRow struct {
	AppointmentID     int64  `json:"appointment_id"`
	EmployeeID        int64  `json:"employee_id"`
	EmployeeFirstName string `json:"employee_first_name"`
	EmployeeLastName  string `json:"employee_last_name"`
}

func (q *Queries) GetParticipantsForAppointments(ctx context.Context, dollar_1 []int32) ([]GetParticipantsForAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, getParticipantsForAppointments, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsForAppointmentsRow
	for rows.Next() {
		var i GetParticipantsForAppointmentsRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.EmployeeID,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
