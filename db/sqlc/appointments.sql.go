// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAppointmentClient = `-- name: AddAppointmentClient :exec
INSERT INTO appointment_clients (
    appointment_id,
    client_id       
) VALUES (
    $1, $2
)
`

type AddAppointmentClientParams struct {
	AppointmentID int64 `json:"appointment_id"`
	ClientID      int64 `json:"client_id"`
}

func (q *Queries) AddAppointmentClient(ctx context.Context, arg AddAppointmentClientParams) error {
	_, err := q.db.Exec(ctx, addAppointmentClient, arg.AppointmentID, arg.ClientID)
	return err
}

const addAppointmentParticipant = `-- name: AddAppointmentParticipant :exec
INSERT INTO appointment_participants (
    appointment_id,
    employee_id     
) VALUES (
    $1, $2
)
`

type AddAppointmentParticipantParams struct {
	AppointmentID int64 `json:"appointment_id"`
	EmployeeID    int64 `json:"employee_id"`
}

func (q *Queries) AddAppointmentParticipant(ctx context.Context, arg AddAppointmentParticipantParams) error {
	_, err := q.db.Exec(ctx, addAppointmentParticipant, arg.AppointmentID, arg.EmployeeID)
	return err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description,          
    status,               
    recurrence_type,      
    recurrence_interval,  
    recurrence_end_date   
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, creator_employee_id, start_time, end_time, location, description, status, recurrence_type, recurrence_interval, recurrence_end_date, confirmed_by_employee_id, confirmed_at, created_at, updated_at
`

type CreateAppointmentParams struct {
	CreatorEmployeeID  int64            `json:"creator_employee_id"`
	StartTime          pgtype.Timestamp `json:"start_time"`
	EndTime            pgtype.Timestamp `json:"end_time"`
	Location           *string          `json:"location"`
	Description        *string          `json:"description"`
	Status             string           `json:"status"`
	RecurrenceType     *string          `json:"recurrence_type"`
	RecurrenceInterval *int32           `json:"recurrence_interval"`
	RecurrenceEndDate  pgtype.Date      `json:"recurrence_end_date"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
		arg.Status,
		arg.RecurrenceType,
		arg.RecurrenceInterval,
		arg.RecurrenceEndDate,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.Status,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.ConfirmedByEmployeeID,
		&i.ConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAppointmentsForEmployeeInRange = `-- name: ListAppointmentsForEmployeeInRange :many
WITH EmployeeAppointments AS (
    -- CTE to get all relevant appointment IDs (both created and participated)
    -- This avoids repeating the logic in the main query parts
    SELECT id AS appointment_id
    FROM appointments a
    WHERE a.creator_employee_id = $1 -- Use parameter $1 for employee_id

    UNION -- Use UNION to automatically handle duplicates

    SELECT appointment_id
    FROM appointment_participants ap
    WHERE ap.employee_id = $1 -- Use parameter $1 for employee_id
),

RecurringOccurrences AS (
    -- CTE to generate potential future occurrences for recurring appointments
    SELECT
        a.id AS original_appointment_id,
        a.creator_employee_id,
        -- Calculate the start time of the specific occurrence
        ts.occurrence_start_time::timestamp AS start_time,
        -- Calculate the end time of the specific occurrence by adding the original duration
        (ts.occurrence_start_time + (a.end_time - a.start_time))::timestamp AS end_time,
        a.location,
        a.description,
        a.status,
        a.recurrence_type,
        a.recurrence_interval,
        a.recurrence_end_date,
        a.confirmed_by_employee_id,
        a.confirmed_at,
        a.created_at,
        a.updated_at,
        TRUE AS is_recurring_occurrence -- Add a flag to indicate this is a generated occurrence
    FROM
        appointments a
    INNER JOIN EmployeeAppointments ea ON a.id = ea.appointment_id -- Only consider appointments involving the employee
    -- Use generate_series to create timestamps based on recurrence rules
    CROSS JOIN LATERAL generate_series(
        -- Start generating from the appointment's original start time
        a.start_time,
        -- Stop generating at the recurrence end date OR the query's end date, whichever is EARLIER
        LEAST(COALESCE(a.recurrence_end_date::timestamp, 'infinity'::timestamp), $2::timestamp), -- Use parameter $3 for end_date
        -- Calculate the interval step based on recurrence type and interval
        CASE a.recurrence_type
            WHEN 'DAILY' THEN (COALESCE(a.recurrence_interval, 1) || ' day')::interval
            WHEN 'WEEKLY' THEN (COALESCE(a.recurrence_interval, 1) || ' week')::interval
            WHEN 'MONTHLY' THEN (COALESCE(a.recurrence_interval, 1) || ' month')::interval
            -- Default to a very large interval if type is NONE or unexpected
            ELSE '1000 years'::interval
        END
    ) AS ts(occurrence_start_time)
    WHERE
        a.recurrence_type != 'NONE' -- Only process recurring appointments
        AND a.recurrence_type IS NOT NULL -- Safety check
        -- Optimization: Ensure the base appointment's start is before the query window ends
        AND a.start_time <= $2::timestamp -- Use parameter $3 for end_date
        -- Optimization: Ensure the recurrence doesn't end before the query window starts
        AND COALESCE(a.recurrence_end_date::timestamp, 'infinity'::timestamp) >= $3::timestamp -- Use parameter $2 for start_date
)

SELECT
    a.id,
    a.creator_employee_id,
    a.start_time,
    a.end_time,
    a.location,
    a.description,
    a.status,
    a.recurrence_type,
    a.recurrence_interval,
    a.recurrence_end_date,
    a.confirmed_by_employee_id,
    a.confirmed_at,
    a.created_at,
    a.updated_at,
    FALSE AS is_recurring_occurrence -- Flag for non-recurring
FROM
    appointments a
INNER JOIN EmployeeAppointments ea ON a.id = ea.appointment_id
WHERE
    a.recurrence_type = 'NONE' -- Select only non-recurring appointments
    -- Standard overlap check: (StartA <= EndB) AND (EndA >= StartB)
    AND (a.start_time <= $2::timestamp) -- Use parameter $3 for end_date
    AND (a.end_time >= $3::timestamp) -- Use parameter $2 for start_date

UNION ALL -- Combine with recurring occurrences, keeping all rows

SELECT
    ro.original_appointment_id AS id, -- Use the original ID for consistency
    ro.creator_employee_id,
    ro.start_time, -- Calculated start time
    ro.end_time,   -- Calculated end time
    ro.location,
    ro.description,
    ro.status,
    ro.recurrence_type,
    ro.recurrence_interval,
    ro.recurrence_end_date,
    ro.confirmed_by_employee_id,
    ro.confirmed_at,
    ro.created_at,
    ro.updated_at,
    ro.is_recurring_occurrence -- Flag indicating it's a calculated occurrence
FROM
    RecurringOccurrences ro
WHERE
    -- Filter the generated occurrences to only those that OVERLAP the requested time frame
    -- Standard overlap check: (StartA <= EndB) AND (EndA >= StartB)
    (ro.start_time <= $2::timestamp) -- Use parameter $3 for end_date
    AND (ro.end_time >= $3::timestamp) -- Use parameter $2 for start_date

ORDER BY start_time
`

type ListAppointmentsForEmployeeInRangeParams struct {
	EmployeeID int64            `json:"employee_id"`
	EndDate    pgtype.Timestamp `json:"end_date"`
	StartDate  pgtype.Timestamp `json:"start_date"`
}

type ListAppointmentsForEmployeeInRangeRow struct {
	ID                    int64            `json:"id"`
	CreatorEmployeeID     int64            `json:"creator_employee_id"`
	StartTime             pgtype.Timestamp `json:"start_time"`
	EndTime               pgtype.Timestamp `json:"end_time"`
	Location              *string          `json:"location"`
	Description           *string          `json:"description"`
	Status                string           `json:"status"`
	RecurrenceType        *string          `json:"recurrence_type"`
	RecurrenceInterval    *int32           `json:"recurrence_interval"`
	RecurrenceEndDate     pgtype.Date      `json:"recurrence_end_date"`
	ConfirmedByEmployeeID *int32           `json:"confirmed_by_employee_id"`
	ConfirmedAt           pgtype.Timestamp `json:"confirmed_at"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
	IsRecurringOccurrence bool             `json:"is_recurring_occurrence"`
}

// Final SELECT combining non-recurring and calculated recurring appointments
// Optional: Order the final results for consistent output
func (q *Queries) ListAppointmentsForEmployeeInRange(ctx context.Context, arg ListAppointmentsForEmployeeInRangeParams) ([]ListAppointmentsForEmployeeInRangeRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsForEmployeeInRange, arg.EmployeeID, arg.EndDate, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsForEmployeeInRangeRow
	for rows.Next() {
		var i ListAppointmentsForEmployeeInRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatorEmployeeID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.RecurrenceType,
			&i.RecurrenceInterval,
			&i.RecurrenceEndDate,
			&i.ConfirmedByEmployeeID,
			&i.ConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsRecurringOccurrence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
