// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkAddAppointmentClients = `-- name: BulkAddAppointmentClients :exec

INSERT INTO appointment_clients (appointment_id, client_id)
SELECT
    $1, -- The single appointment_id
    unnest($2::bigint[])
`

type BulkAddAppointmentClientsParams struct {
	AppointmentID int64   `json:"appointment_id"`
	ClientIds     []int64 `json:"client_ids"`
}

// The array of employee_id
func (q *Queries) BulkAddAppointmentClients(ctx context.Context, arg BulkAddAppointmentClientsParams) error {
	_, err := q.db.Exec(ctx, bulkAddAppointmentClients, arg.AppointmentID, arg.ClientIds)
	return err
}

const bulkAddAppointmentParticipants = `-- name: BulkAddAppointmentParticipants :exec
INSERT INTO appointment_participants (appointment_id, employee_id)
SELECT
    $1, -- The single appointment_id
    unnest($2::bigint[])
`

type BulkAddAppointmentParticipantsParams struct {
	AppointmentID int64   `json:"appointment_id"`
	EmployeeIds   []int64 `json:"employee_ids"`
}

func (q *Queries) BulkAddAppointmentParticipants(ctx context.Context, arg BulkAddAppointmentParticipantsParams) error {
	_, err := q.db.Exec(ctx, bulkAddAppointmentParticipants, arg.AppointmentID, arg.EmployeeIds)
	return err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO scheduled_appointments (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description       
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, appointment_templates_id, creator_employee_id, start_time, end_time, location, description, status, confirmed_by_employee_id, confirmed_at, created_at, updated_at
`

type CreateAppointmentParams struct {
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (ScheduledAppointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
	)
	var i ScheduledAppointment
	err := row.Scan(
		&i.ID,
		&i.AppointmentTemplatesID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.Status,
		&i.ConfirmedByEmployeeID,
		&i.ConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAppointmentTemplate = `-- name: CreateAppointmentTemplate :one
INSERT INTO appointment_templates (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description,          
    recurrence_type,
    recurrence_interval,
    recurrence_end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, creator_employee_id, start_time, end_time, location, description, recurrence_type, recurrence_interval, recurrence_end_date, created_at, updated_at
`

type CreateAppointmentTemplateParams struct {
	CreatorEmployeeID  int64            `json:"creator_employee_id"`
	StartTime          pgtype.Timestamp `json:"start_time"`
	EndTime            pgtype.Timestamp `json:"end_time"`
	Location           *string          `json:"location"`
	Description        *string          `json:"description"`
	RecurrenceType     *string          `json:"recurrence_type"`
	RecurrenceInterval *int32           `json:"recurrence_interval"`
	RecurrenceEndDate  pgtype.Date      `json:"recurrence_end_date"`
}

func (q *Queries) CreateAppointmentTemplate(ctx context.Context, arg CreateAppointmentTemplateParams) (AppointmentTemplate, error) {
	row := q.db.QueryRow(ctx, createAppointmentTemplate,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
		arg.RecurrenceType,
		arg.RecurrenceInterval,
		arg.RecurrenceEndDate,
	)
	var i AppointmentTemplate
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppointmentTemplate = `-- name: GetAppointmentTemplate :one




SELECT id, creator_employee_id, start_time, end_time, location, description, recurrence_type, recurrence_interval, recurrence_end_date, created_at, updated_at FROM appointment_templates
WHERE id = $1
LIMIT 1
`

// The array of client_ids
func (q *Queries) GetAppointmentTemplate(ctx context.Context, id int64) (AppointmentTemplate, error) {
	row := q.db.QueryRow(ctx, getAppointmentTemplate, id)
	var i AppointmentTemplate
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClientAppointmentsInRange = `-- name: ListClientAppointmentsInRange :many
SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.creator_employee_id, -- Include creator info if needed
    sa.created_at
    -- No 'involvement_type' needed as clients are always participants in this context
FROM
    scheduled_appointments sa
JOIN
    appointment_clients ac ON sa.id = ac.appointment_id
WHERE
    ac.client_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

ORDER BY
    sa.start_time
`

type ListClientAppointmentsInRangeParams struct {
	ClientID  int64            `json:"client_id"`
	EndDate   pgtype.Timestamp `json:"end_date"`
	StartDate pgtype.Timestamp `json:"start_date"`
}

type ListClientAppointmentsInRangeRow struct {
	AppointmentID     int64            `json:"appointment_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
	Status            string           `json:"status"`
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

// Define the parameters for the query
// client_id: The ID of the client whose appointments are being queried.
// start_date: The beginning of the time range to search within (inclusive).
// end_date: The end of the time range to search within (exclusive).
// Order the results by start time
func (q *Queries) ListClientAppointmentsInRange(ctx context.Context, arg ListClientAppointmentsInRangeParams) ([]ListClientAppointmentsInRangeRow, error) {
	rows, err := q.db.Query(ctx, listClientAppointmentsInRange, arg.ClientID, arg.EndDate, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientAppointmentsInRangeRow
	for rows.Next() {
		var i ListClientAppointmentsInRangeRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.CreatorEmployeeID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeeAppointmentsInRange = `-- name: ListEmployeeAppointmentsInRange :many
SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.creator_employee_id,
    sa.created_at,
    'CREATOR' AS involvement_type -- Indicate the employee created this appointment
FROM
    scheduled_appointments sa
WHERE
    sa.creator_employee_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

UNION -- Combine with participant appointments, removing duplicates

SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.creator_employee_id, -- Still show who created it
    sa.created_at,
    'PARTICIPANT' AS involvement_type -- Indicate the employee is a participant
FROM
    scheduled_appointments sa
JOIN
    appointment_participants ap ON sa.id = ap.appointment_id
WHERE
    ap.employee_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

ORDER BY
    start_time
`

type ListEmployeeAppointmentsInRangeParams struct {
	EmployeeID *int64           `json:"employee_id"`
	EndDate    pgtype.Timestamp `json:"end_date"`
	StartDate  pgtype.Timestamp `json:"start_date"`
}

type ListEmployeeAppointmentsInRangeRow struct {
	AppointmentID     int64            `json:"appointment_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
	Status            string           `json:"status"`
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	InvolvementType   string           `json:"involvement_type"`
}

// Define the parameters for the query
// employee_id: The ID of the employee whose appointments are being queried.
// start_date: The beginning of the time range to search within.
// end_date: The end of the time range to search within.
// Order the combined results by start time
func (q *Queries) ListEmployeeAppointmentsInRange(ctx context.Context, arg ListEmployeeAppointmentsInRangeParams) ([]ListEmployeeAppointmentsInRangeRow, error) {
	rows, err := q.db.Query(ctx, listEmployeeAppointmentsInRange, arg.EmployeeID, arg.EndDate, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeeAppointmentsInRangeRow
	for rows.Next() {
		var i ListEmployeeAppointmentsInRangeRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.CreatorEmployeeID,
			&i.CreatedAt,
			&i.InvolvementType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
