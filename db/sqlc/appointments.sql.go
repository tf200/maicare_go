// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkAddAppointmentClients = `-- name: BulkAddAppointmentClients :exec

INSERT INTO appointment_clients (appointment_id, client_id)
SELECT
    $1, -- The single appointment_id
    unnest($2::bigint[])
`

type BulkAddAppointmentClientsParams struct {
	AppointmentID int64   `json:"appointment_id"`
	ClientIds     []int64 `json:"client_ids"`
}

// The array of employee_id
func (q *Queries) BulkAddAppointmentClients(ctx context.Context, arg BulkAddAppointmentClientsParams) error {
	_, err := q.db.Exec(ctx, bulkAddAppointmentClients, arg.AppointmentID, arg.ClientIds)
	return err
}

const bulkAddAppointmentParticipants = `-- name: BulkAddAppointmentParticipants :exec
INSERT INTO appointment_participants (appointment_id, employee_id)
SELECT
    $1, -- The single appointment_id
    unnest($2::bigint[])
`

type BulkAddAppointmentParticipantsParams struct {
	AppointmentID int64   `json:"appointment_id"`
	EmployeeIds   []int64 `json:"employee_ids"`
}

func (q *Queries) BulkAddAppointmentParticipants(ctx context.Context, arg BulkAddAppointmentParticipantsParams) error {
	_, err := q.db.Exec(ctx, bulkAddAppointmentParticipants, arg.AppointmentID, arg.EmployeeIds)
	return err
}

const confirmAppointment = `-- name: ConfirmAppointment :exec



UPDATE scheduled_appointments
SET
    status = 'CONFIRMED',
    is_confirmed = true,
    confirmed_by_employee_id = $2,
    confirmed_at = NOW()
WHERE id = $1
`

type ConfirmAppointmentParams struct {
	ID         int64  `json:"id"`
	EmployeeID *int64 `json:"employee_id"`
}

// Optional ordering
func (q *Queries) ConfirmAppointment(ctx context.Context, arg ConfirmAppointmentParams) error {
	_, err := q.db.Exec(ctx, confirmAppointment, arg.ID, arg.EmployeeID)
	return err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO scheduled_appointments (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description       
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, appointment_templates_id, creator_employee_id, start_time, end_time, location, description, status, is_confirmed, confirmed_by_employee_id, confirmed_at, created_at, updated_at
`

type CreateAppointmentParams struct {
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (ScheduledAppointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
	)
	var i ScheduledAppointment
	err := row.Scan(
		&i.ID,
		&i.AppointmentTemplatesID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.Status,
		&i.IsConfirmed,
		&i.ConfirmedByEmployeeID,
		&i.ConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAppointmentTemplate = `-- name: CreateAppointmentTemplate :one
INSERT INTO appointment_templates (
    creator_employee_id, 
    start_time,           
    end_time,             
    location,             
    description,          
    recurrence_type,
    recurrence_interval,
    recurrence_end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, creator_employee_id, start_time, end_time, location, description, recurrence_type, recurrence_interval, recurrence_end_date, created_at, updated_at
`

type CreateAppointmentTemplateParams struct {
	CreatorEmployeeID  int64            `json:"creator_employee_id"`
	StartTime          pgtype.Timestamp `json:"start_time"`
	EndTime            pgtype.Timestamp `json:"end_time"`
	Location           *string          `json:"location"`
	Description        *string          `json:"description"`
	RecurrenceType     *string          `json:"recurrence_type"`
	RecurrenceInterval *int32           `json:"recurrence_interval"`
	RecurrenceEndDate  pgtype.Date      `json:"recurrence_end_date"`
}

func (q *Queries) CreateAppointmentTemplate(ctx context.Context, arg CreateAppointmentTemplateParams) (AppointmentTemplate, error) {
	row := q.db.QueryRow(ctx, createAppointmentTemplate,
		arg.CreatorEmployeeID,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Description,
		arg.RecurrenceType,
		arg.RecurrenceInterval,
		arg.RecurrenceEndDate,
	)
	var i AppointmentTemplate
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppointmentClients = `-- name: GetAppointmentClients :many



SELECT
    cd.id AS client_id,
    cd.first_name,
    cd.last_name
FROM
    appointment_clients ac
JOIN
    client_details cd ON ac.client_id = cd.id
WHERE
    ac.appointment_id = $1 -- Filter by appointment ID
ORDER BY
    cd.last_name, cd.first_name
`

type GetAppointmentClientsRow struct {
	ClientID  int64  `json:"client_id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

// Optional ordering
func (q *Queries) GetAppointmentClients(ctx context.Context, appointmentID int64) ([]GetAppointmentClientsRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentClients, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppointmentClientsRow
	for rows.Next() {
		var i GetAppointmentClientsRow
		if err := rows.Scan(&i.ClientID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentParticipants = `-- name: GetAppointmentParticipants :many
SELECT
    ep.id AS employee_id,
    ep.first_name,
    ep.last_name
FROM
    appointment_participants ap
JOIN
    employee_profile ep ON ap.employee_id = ep.id
WHERE
    ap.appointment_id = $1 -- Filter by appointment ID
ORDER BY
    ep.last_name, ep.first_name
`

type GetAppointmentParticipantsRow struct {
	EmployeeID int64  `json:"employee_id"`
	FirstName  string `json:"first_name"`
	LastName   string `json:"last_name"`
}

func (q *Queries) GetAppointmentParticipants(ctx context.Context, appointmentID int64) ([]GetAppointmentParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentParticipants, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppointmentParticipantsRow
	for rows.Next() {
		var i GetAppointmentParticipantsRow
		if err := rows.Scan(&i.EmployeeID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentTemplate = `-- name: GetAppointmentTemplate :one




SELECT id, creator_employee_id, start_time, end_time, location, description, recurrence_type, recurrence_interval, recurrence_end_date, created_at, updated_at FROM appointment_templates
WHERE id = $1
LIMIT 1
`

// The array of client_ids
func (q *Queries) GetAppointmentTemplate(ctx context.Context, id int64) (AppointmentTemplate, error) {
	row := q.db.QueryRow(ctx, getAppointmentTemplate, id)
	var i AppointmentTemplate
	err := row.Scan(
		&i.ID,
		&i.CreatorEmployeeID,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.RecurrenceType,
		&i.RecurrenceInterval,
		&i.RecurrenceEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduledAppointmentByID = `-- name: GetScheduledAppointmentByID :one
SELECT
    sa.id,
    sa.appointment_templates_id,
    sa.creator_employee_id,
    creator.first_name AS creator_first_name, -- Alias creator details
    creator.last_name AS creator_last_name,   -- Alias creator details
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.is_confirmed,
    sa.confirmed_by_employee_id,
    confirmer.first_name AS confirmer_first_name, -- Alias confirmer details
    confirmer.last_name AS confirmer_last_name,   -- Alias confirmer details
    sa.confirmed_at,
    sa.created_at,
    sa.updated_at
FROM
    scheduled_appointments sa
LEFT JOIN
    employee_profile creator ON sa.creator_employee_id = creator.id -- Join for creator
LEFT JOIN
    employee_profile confirmer ON sa.confirmed_by_employee_id = confirmer.id -- Join for confirmer
WHERE
    sa.id = $1 -- Filter by appointment ID
LIMIT 1
`

type GetScheduledAppointmentByIDRow struct {
	ID                     int64            `json:"id"`
	AppointmentTemplatesID *int64           `json:"appointment_templates_id"`
	CreatorEmployeeID      *int64           `json:"creator_employee_id"`
	CreatorFirstName       *string          `json:"creator_first_name"`
	CreatorLastName        *string          `json:"creator_last_name"`
	StartTime              pgtype.Timestamp `json:"start_time"`
	EndTime                pgtype.Timestamp `json:"end_time"`
	Location               *string          `json:"location"`
	Description            *string          `json:"description"`
	Status                 string           `json:"status"`
	IsConfirmed            bool             `json:"is_confirmed"`
	ConfirmedByEmployeeID  *int64           `json:"confirmed_by_employee_id"`
	ConfirmerFirstName     *string          `json:"confirmer_first_name"`
	ConfirmerLastName      *string          `json:"confirmer_last_name"`
	ConfirmedAt            pgtype.Timestamp `json:"confirmed_at"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetScheduledAppointmentByID(ctx context.Context, id int64) (GetScheduledAppointmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getScheduledAppointmentByID, id)
	var i GetScheduledAppointmentByIDRow
	err := row.Scan(
		&i.ID,
		&i.AppointmentTemplatesID,
		&i.CreatorEmployeeID,
		&i.CreatorFirstName,
		&i.CreatorLastName,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.Description,
		&i.Status,
		&i.IsConfirmed,
		&i.ConfirmedByEmployeeID,
		&i.ConfirmerFirstName,
		&i.ConfirmerLastName,
		&i.ConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClientAppointmentsInRange = `-- name: ListClientAppointmentsInRange :many
SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.creator_employee_id, -- Include creator info if needed
    sa.created_at
    -- No 'involvement_type' needed as clients are always participants in this context
FROM
    scheduled_appointments sa
JOIN
    appointment_clients ac ON sa.id = ac.appointment_id
WHERE
    ac.client_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

ORDER BY
    sa.start_time
`

type ListClientAppointmentsInRangeParams struct {
	ClientID  int64            `json:"client_id"`
	EndDate   pgtype.Timestamp `json:"end_date"`
	StartDate pgtype.Timestamp `json:"start_date"`
}

type ListClientAppointmentsInRangeRow struct {
	AppointmentID     int64            `json:"appointment_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
	Status            string           `json:"status"`
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

// Define the parameters for the query
// client_id: The ID of the client whose appointments are being queried.
// start_date: The beginning of the time range to search within (inclusive).
// end_date: The end of the time range to search within (exclusive).
// Order the results by start time
func (q *Queries) ListClientAppointmentsInRange(ctx context.Context, arg ListClientAppointmentsInRangeParams) ([]ListClientAppointmentsInRangeRow, error) {
	rows, err := q.db.Query(ctx, listClientAppointmentsInRange, arg.ClientID, arg.EndDate, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientAppointmentsInRangeRow
	for rows.Next() {
		var i ListClientAppointmentsInRangeRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.CreatorEmployeeID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeeAppointmentsInRange = `-- name: ListEmployeeAppointmentsInRange :many
SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.is_confirmed,
    sa.creator_employee_id,
    sa.created_at,
    'CREATOR' AS involvement_type -- Indicate the employee created this appointment
FROM
    scheduled_appointments sa
WHERE
    sa.creator_employee_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

UNION -- Combine with participant appointments, removing duplicates

SELECT
    sa.id AS appointment_id,
    sa.start_time,
    sa.end_time,
    sa.location,
    sa.description,
    sa.status,
    sa.creator_employee_id, -- Still show who created it
    sa.created_at,
    'PARTICIPANT' AS involvement_type -- Indicate the employee is a participant
FROM
    scheduled_appointments sa
JOIN
    appointment_participants ap ON sa.id = ap.appointment_id
WHERE
    ap.employee_id = $1
    -- Check for overlap: Appointment starts before the range ends AND appointment ends after the range starts
    AND sa.start_time < $2
    AND sa.end_time > $3

ORDER BY
    start_time
`

type ListEmployeeAppointmentsInRangeParams struct {
	EmployeeID *int64           `json:"employee_id"`
	EndDate    pgtype.Timestamp `json:"end_date"`
	StartDate  pgtype.Timestamp `json:"start_date"`
}

type ListEmployeeAppointmentsInRangeRow struct {
	AppointmentID     int64            `json:"appointment_id"`
	StartTime         pgtype.Timestamp `json:"start_time"`
	EndTime           pgtype.Timestamp `json:"end_time"`
	Location          *string          `json:"location"`
	Description       *string          `json:"description"`
	Status            string           `json:"status"`
	IsConfirmed       bool             `json:"is_confirmed"`
	CreatorEmployeeID *int64           `json:"creator_employee_id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	InvolvementType   string           `json:"involvement_type"`
}

// Define the parameters for the query
// employee_id: The ID of the employee whose appointments are being queried.
// start_date: The beginning of the time range to search within.
// end_date: The end of the time range to search within.
// Order the combined results by start time
func (q *Queries) ListEmployeeAppointmentsInRange(ctx context.Context, arg ListEmployeeAppointmentsInRangeParams) ([]ListEmployeeAppointmentsInRangeRow, error) {
	rows, err := q.db.Query(ctx, listEmployeeAppointmentsInRange, arg.EmployeeID, arg.EndDate, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeeAppointmentsInRangeRow
	for rows.Next() {
		var i ListEmployeeAppointmentsInRangeRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Description,
			&i.Status,
			&i.IsConfirmed,
			&i.CreatorEmployeeID,
			&i.CreatedAt,
			&i.InvolvementType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
