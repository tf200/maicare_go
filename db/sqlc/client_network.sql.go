// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client_network.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignEmployee = `-- name: AssignEmployee :one
WITH inserted_assignment AS (
    -- Perform the insert and return the inserted row
    INSERT INTO assigned_employee (
        client_id,
        employee_id,
        start_date,
        role
    ) VALUES (
        $1, $2, $3, $4
    )
    RETURNING id, client_id, employee_id, start_date, role, created_at -- Return all columns from the inserted assigned_employee row
)
SELECT
    ia.id, ia.client_id, ia.employee_id, ia.start_date, ia.role, ia.created_at,  -- Select all columns from the inserted_assignment CTE
    ep.user_id, -- Select the user_id from the employee_profile table
    cl.first_name AS client_first_name,
    cl.last_name AS client_last_name,
    l.name AS client_location_name
FROM
    inserted_assignment ia
JOIN
    employee_profile ep ON ia.employee_id = ep.id -- Join based on employee_id
JOIN
    client_details cl ON ia.client_id = cl.id
LEFT JOIN
    location l ON cl.location_id = l.id
`

type AssignEmployeeParams struct {
	ClientID   int64       `json:"client_id"`
	EmployeeID int64       `json:"employee_id"`
	StartDate  pgtype.Date `json:"start_date"`
	Role       string      `json:"role"`
}

type AssignEmployeeRow struct {
	ID                 int64              `json:"id"`
	ClientID           int64              `json:"client_id"`
	EmployeeID         int64              `json:"employee_id"`
	StartDate          pgtype.Date        `json:"start_date"`
	Role               string             `json:"role"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UserID             int64              `json:"user_id"`
	ClientFirstName    string             `json:"client_first_name"`
	ClientLastName     string             `json:"client_last_name"`
	ClientLocationName *string            `json:"client_location_name"`
}

// Select the columns from the inserted row AND join to get the user_id
func (q *Queries) AssignEmployee(ctx context.Context, arg AssignEmployeeParams) (AssignEmployeeRow, error) {
	row := q.db.QueryRow(ctx, assignEmployee,
		arg.ClientID,
		arg.EmployeeID,
		arg.StartDate,
		arg.Role,
	)
	var i AssignEmployeeRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.EmployeeID,
		&i.StartDate,
		&i.Role,
		&i.CreatedAt,
		&i.UserID,
		&i.ClientFirstName,
		&i.ClientLastName,
		&i.ClientLocationName,
	)
	return i, err
}

const assignSender = `-- name: AssignSender :one
UPDATE client_details
SET sender_id = $1
WHERE id = $2
RETURNING id, intake_form_id, first_name, last_name, date_of_birth, identity, status, bsn, bsn_verified_by, source, birthplace, email, phone_number, organisation, departement, gender, filenumber, profile_picture, infix, created_at, sender_id, location_id, departure_reason, departure_report, gps_position, maturity_domains, addresses, legal_measure, has_untaken_medications, education_currently_enrolled, education_institution, education_mentor_name, education_mentor_phone, education_mentor_email, education_additional_notes, education_level, work_currently_employed, work_current_employer, work_current_employer_phone, work_current_employer_email, work_current_position, work_start_date, work_additional_notes, living_situation, living_situation_notes
`

type AssignSenderParams struct {
	SenderID *int64 `json:"sender_id"`
	ID       int64  `json:"id"`
}

func (q *Queries) AssignSender(ctx context.Context, arg AssignSenderParams) (ClientDetail, error) {
	row := q.db.QueryRow(ctx, assignSender, arg.SenderID, arg.ID)
	var i ClientDetail
	err := row.Scan(
		&i.ID,
		&i.IntakeFormID,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Identity,
		&i.Status,
		&i.Bsn,
		&i.BsnVerifiedBy,
		&i.Source,
		&i.Birthplace,
		&i.Email,
		&i.PhoneNumber,
		&i.Organisation,
		&i.Departement,
		&i.Gender,
		&i.Filenumber,
		&i.ProfilePicture,
		&i.Infix,
		&i.CreatedAt,
		&i.SenderID,
		&i.LocationID,
		&i.DepartureReason,
		&i.DepartureReport,
		&i.GpsPosition,
		&i.MaturityDomains,
		&i.Addresses,
		&i.LegalMeasure,
		&i.HasUntakenMedications,
		&i.EducationCurrentlyEnrolled,
		&i.EducationInstitution,
		&i.EducationMentorName,
		&i.EducationMentorPhone,
		&i.EducationMentorEmail,
		&i.EducationAdditionalNotes,
		&i.EducationLevel,
		&i.WorkCurrentlyEmployed,
		&i.WorkCurrentEmployer,
		&i.WorkCurrentEmployerPhone,
		&i.WorkCurrentEmployerEmail,
		&i.WorkCurrentPosition,
		&i.WorkStartDate,
		&i.WorkAdditionalNotes,
		&i.LivingSituation,
		&i.LivingSituationNotes,
	)
	return i, err
}

const createEmemrgencyContact = `-- name: CreateEmemrgencyContact :one
INSERT INTO client_emergency_contact (
    client_id,
    first_name,
    last_name,
    email,
    phone_number,
    address,
    relationship,
    relation_status,
    medical_reports,
    incidents_reports,
    goals_reports
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, client_id, first_name, last_name, email, phone_number, address, relationship, relation_status, created_at, is_verified, medical_reports, incidents_reports, goals_reports
`

type CreateEmemrgencyContactParams struct {
	ClientID         int64   `json:"client_id"`
	FirstName        *string `json:"first_name"`
	LastName         *string `json:"last_name"`
	Email            *string `json:"email"`
	PhoneNumber      *string `json:"phone_number"`
	Address          *string `json:"address"`
	Relationship     *string `json:"relationship"`
	RelationStatus   *string `json:"relation_status"`
	MedicalReports   bool    `json:"medical_reports"`
	IncidentsReports bool    `json:"incidents_reports"`
	GoalsReports     bool    `json:"goals_reports"`
}

func (q *Queries) CreateEmemrgencyContact(ctx context.Context, arg CreateEmemrgencyContactParams) (ClientEmergencyContact, error) {
	row := q.db.QueryRow(ctx, createEmemrgencyContact,
		arg.ClientID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.Address,
		arg.Relationship,
		arg.RelationStatus,
		arg.MedicalReports,
		arg.IncidentsReports,
		arg.GoalsReports,
	)
	var i ClientEmergencyContact
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.Address,
		&i.Relationship,
		&i.RelationStatus,
		&i.CreatedAt,
		&i.IsVerified,
		&i.MedicalReports,
		&i.IncidentsReports,
		&i.GoalsReports,
	)
	return i, err
}

const deleteAssignedEmployee = `-- name: DeleteAssignedEmployee :one
DELETE FROM assigned_employee
WHERE id = $1
RETURNING id, client_id, employee_id, start_date, role, created_at
`

func (q *Queries) DeleteAssignedEmployee(ctx context.Context, id int64) (AssignedEmployee, error) {
	row := q.db.QueryRow(ctx, deleteAssignedEmployee, id)
	var i AssignedEmployee
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.EmployeeID,
		&i.StartDate,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmergencyContact = `-- name: DeleteEmergencyContact :one
DELETE FROM client_emergency_contact
WHERE id = $1
RETURNING id, client_id, first_name, last_name, email, phone_number, address, relationship, relation_status, created_at, is_verified, medical_reports, incidents_reports, goals_reports
`

func (q *Queries) DeleteEmergencyContact(ctx context.Context, id int64) (ClientEmergencyContact, error) {
	row := q.db.QueryRow(ctx, deleteEmergencyContact, id)
	var i ClientEmergencyContact
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.Address,
		&i.Relationship,
		&i.RelationStatus,
		&i.CreatedAt,
		&i.IsVerified,
		&i.MedicalReports,
		&i.IncidentsReports,
		&i.GoalsReports,
	)
	return i, err
}

const getAssignedEmployee = `-- name: GetAssignedEmployee :one
SELECT 
    ae.id, ae.client_id, ae.employee_id, ae.start_date, ae.role, ae.created_at,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name
FROM assigned_employee ae
JOIN employee_profile e ON ae.employee_id = e.id
WHERE ae.id = $1 LIMIT 1
`

type GetAssignedEmployeeRow struct {
	ID                int64              `json:"id"`
	ClientID          int64              `json:"client_id"`
	EmployeeID        int64              `json:"employee_id"`
	StartDate         pgtype.Date        `json:"start_date"`
	Role              string             `json:"role"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	EmployeeFirstName string             `json:"employee_first_name"`
	EmployeeLastName  string             `json:"employee_last_name"`
}

func (q *Queries) GetAssignedEmployee(ctx context.Context, id int64) (GetAssignedEmployeeRow, error) {
	row := q.db.QueryRow(ctx, getAssignedEmployee, id)
	var i GetAssignedEmployeeRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.EmployeeID,
		&i.StartDate,
		&i.Role,
		&i.CreatedAt,
		&i.EmployeeFirstName,
		&i.EmployeeLastName,
	)
	return i, err
}

const getClientRelatedEmails = `-- name: GetClientRelatedEmails :many
WITH employee_emails AS (
    SELECT ed.email AS employee_email
    FROM assigned_employee ae
    JOIN employee_profile ed ON ae.employee_id = ed.id
    WHERE ae.client_id = $1
),
emergency_contact_emails AS (
    SELECT cec.email AS contact_email
    FROM client_emergency_contact cec
    WHERE cec.client_id = $1
)
SELECT employee_email FROM employee_emails
UNION
SELECT contact_email FROM emergency_contact_emails
`

func (q *Queries) GetClientRelatedEmails(ctx context.Context, clientID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getClientRelatedEmails, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var employee_email string
		if err := rows.Scan(&employee_email); err != nil {
			return nil, err
		}
		items = append(items, employee_email)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientSender = `-- name: GetClientSender :one
SELECT s.id, s.types, s.name, s.address, s.postal_code, s.place, s.land, s.kvknumber, s.btwnumber, s.phone_number, s.client_number, s.email_address, s.contacts, s.invoice_template, s.is_archived, s.created_at, s.updated_at FROM sender s
LEFT JOIN client_details cd ON s.id = cd.sender_id
WHERE cd.id = $1
LIMIT 1
`

func (q *Queries) GetClientSender(ctx context.Context, id int64) (Sender, error) {
	row := q.db.QueryRow(ctx, getClientSender, id)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.Types,
		&i.Name,
		&i.Address,
		&i.PostalCode,
		&i.Place,
		&i.Land,
		&i.Kvknumber,
		&i.Btwnumber,
		&i.PhoneNumber,
		&i.ClientNumber,
		&i.EmailAddress,
		&i.Contacts,
		&i.InvoiceTemplate,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmergencyContact = `-- name: GetEmergencyContact :one
SELECT id, client_id, first_name, last_name, email, phone_number, address, relationship, relation_status, created_at, is_verified, medical_reports, incidents_reports, goals_reports FROM client_emergency_contact
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEmergencyContact(ctx context.Context, id int64) (ClientEmergencyContact, error) {
	row := q.db.QueryRow(ctx, getEmergencyContact, id)
	var i ClientEmergencyContact
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.Address,
		&i.Relationship,
		&i.RelationStatus,
		&i.CreatedAt,
		&i.IsVerified,
		&i.MedicalReports,
		&i.IncidentsReports,
		&i.GoalsReports,
	)
	return i, err
}

const listAssignedEmployees = `-- name: ListAssignedEmployees :many




SELECT 
    ae.id, ae.client_id, ae.employee_id, ae.start_date, ae.role, ae.created_at,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name,
    COUNT(*) OVER() as total_count
FROM assigned_employee ae
JOIN employee_profile e ON ae.employee_id = e.id
WHERE ae.client_id = $1
ORDER BY ae.start_date DESC
LIMIT $2 OFFSET $3
`

type ListAssignedEmployeesParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListAssignedEmployeesRow struct {
	ID                int64              `json:"id"`
	ClientID          int64              `json:"client_id"`
	EmployeeID        int64              `json:"employee_id"`
	StartDate         pgtype.Date        `json:"start_date"`
	Role              string             `json:"role"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	EmployeeFirstName string             `json:"employee_first_name"`
	EmployeeLastName  string             `json:"employee_last_name"`
	TotalCount        int64              `json:"total_count"`
}

// Join to get the client location name
func (q *Queries) ListAssignedEmployees(ctx context.Context, arg ListAssignedEmployeesParams) ([]ListAssignedEmployeesRow, error) {
	rows, err := q.db.Query(ctx, listAssignedEmployees, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssignedEmployeesRow
	for rows.Next() {
		var i ListAssignedEmployeesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.EmployeeID,
			&i.StartDate,
			&i.Role,
			&i.CreatedAt,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmergencyContacts = `-- name: ListEmergencyContacts :many
SELECT 
    ec.id, ec.client_id, ec.first_name, ec.last_name, ec.email, ec.phone_number, ec.address, ec.relationship, ec.relation_status, ec.created_at, ec.is_verified, ec.medical_reports, ec.incidents_reports, ec.goals_reports,
    COUNT(*) OVER() as total_count
FROM client_emergency_contact ec
WHERE client_id = $3
    AND (
        LOWER(first_name) LIKE LOWER(CONCAT('%', $4::text, '%')) OR
        LOWER(last_name) LIKE LOWER(CONCAT('%', $4::text, '%'))
    )
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListEmergencyContactsParams struct {
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
	ClientID int64  `json:"client_id"`
	Search   string `json:"search"`
}

type ListEmergencyContactsRow struct {
	ID               int64              `json:"id"`
	ClientID         int64              `json:"client_id"`
	FirstName        *string            `json:"first_name"`
	LastName         *string            `json:"last_name"`
	Email            *string            `json:"email"`
	PhoneNumber      *string            `json:"phone_number"`
	Address          *string            `json:"address"`
	Relationship     *string            `json:"relationship"`
	RelationStatus   *string            `json:"relation_status"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	IsVerified       bool               `json:"is_verified"`
	MedicalReports   bool               `json:"medical_reports"`
	IncidentsReports bool               `json:"incidents_reports"`
	GoalsReports     bool               `json:"goals_reports"`
	TotalCount       int64              `json:"total_count"`
}

func (q *Queries) ListEmergencyContacts(ctx context.Context, arg ListEmergencyContactsParams) ([]ListEmergencyContactsRow, error) {
	rows, err := q.db.Query(ctx, listEmergencyContacts,
		arg.Limit,
		arg.Offset,
		arg.ClientID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmergencyContactsRow
	for rows.Next() {
		var i ListEmergencyContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PhoneNumber,
			&i.Address,
			&i.Relationship,
			&i.RelationStatus,
			&i.CreatedAt,
			&i.IsVerified,
			&i.MedicalReports,
			&i.IncidentsReports,
			&i.GoalsReports,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignedEmployee = `-- name: UpdateAssignedEmployee :one
UPDATE assigned_employee
SET
    employee_id = COALESCE($2, employee_id),
    start_date = COALESCE($3, start_date),
    role = COALESCE($4, role)
WHERE id = $1
RETURNING id, client_id, employee_id, start_date, role, created_at
`

type UpdateAssignedEmployeeParams struct {
	ID         int64       `json:"id"`
	EmployeeID *int64      `json:"employee_id"`
	StartDate  pgtype.Date `json:"start_date"`
	Role       *string     `json:"role"`
}

func (q *Queries) UpdateAssignedEmployee(ctx context.Context, arg UpdateAssignedEmployeeParams) (AssignedEmployee, error) {
	row := q.db.QueryRow(ctx, updateAssignedEmployee,
		arg.ID,
		arg.EmployeeID,
		arg.StartDate,
		arg.Role,
	)
	var i AssignedEmployee
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.EmployeeID,
		&i.StartDate,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const updateEmergencyContact = `-- name: UpdateEmergencyContact :one
UPDATE client_emergency_contact
SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    email = COALESCE($4, email),
    phone_number = COALESCE($5, phone_number),
    address = COALESCE($6, address),
    relationship = COALESCE($7, relationship),
    relation_status = COALESCE($8, relation_status),
    medical_reports = COALESCE($9, medical_reports),
    incidents_reports = COALESCE($10, incidents_reports),
    goals_reports = COALESCE($11, goals_reports)
WHERE id = $1
RETURNING id, client_id, first_name, last_name, email, phone_number, address, relationship, relation_status, created_at, is_verified, medical_reports, incidents_reports, goals_reports
`

type UpdateEmergencyContactParams struct {
	ID               int64   `json:"id"`
	FirstName        *string `json:"first_name"`
	LastName         *string `json:"last_name"`
	Email            *string `json:"email"`
	PhoneNumber      *string `json:"phone_number"`
	Address          *string `json:"address"`
	Relationship     *string `json:"relationship"`
	RelationStatus   *string `json:"relation_status"`
	MedicalReports   *bool   `json:"medical_reports"`
	IncidentsReports *bool   `json:"incidents_reports"`
	GoalsReports     *bool   `json:"goals_reports"`
}

func (q *Queries) UpdateEmergencyContact(ctx context.Context, arg UpdateEmergencyContactParams) (ClientEmergencyContact, error) {
	row := q.db.QueryRow(ctx, updateEmergencyContact,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.PhoneNumber,
		arg.Address,
		arg.Relationship,
		arg.RelationStatus,
		arg.MedicalReports,
		arg.IncidentsReports,
		arg.GoalsReports,
	)
	var i ClientEmergencyContact
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.PhoneNumber,
		&i.Address,
		&i.Relationship,
		&i.RelationStatus,
		&i.CreatedAt,
		&i.IsVerified,
		&i.MedicalReports,
		&i.IncidentsReports,
		&i.GoalsReports,
	)
	return i, err
}
