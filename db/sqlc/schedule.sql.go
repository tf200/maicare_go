// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (
    employee_id,
    location_id,
    start_datetime,
    end_datetime
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, employee_id, location_id, start_datetime, end_datetime, created_at, updated_at
`

type CreateScheduleParams struct {
	EmployeeID    int64            `json:"employee_id"`
	LocationID    int64            `json:"location_id"`
	StartDatetime pgtype.Timestamp `json:"start_datetime"`
	EndDatetime   pgtype.Timestamp `json:"end_datetime"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.EmployeeID,
		arg.LocationID,
		arg.StartDatetime,
		arg.EndDatetime,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.LocationID,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMonthlySchedulesByLocation = `-- name: GetMonthlySchedulesByLocation :many
WITH target_month AS (
  SELECT make_date($1, $2, 1) AS start_date
),
dates AS (
  SELECT generate_series(
    (SELECT start_date FROM target_month),
    (SELECT start_date + INTERVAL '1 month - 1 day' FROM target_month),
    INTERVAL '1 day'
  )::date AS day
),
shift_days AS (
  SELECT 
    s.id AS shift_id,
    s.employee_id,
    s.location_id,
    s.start_datetime,
    s.end_datetime,
    d.day,
    e.first_name AS employee_first_name
  FROM schedules s
  JOIN dates d 
    ON d.day BETWEEN DATE(s.start_datetime) AND DATE(s.end_datetime)
  JOIN employee_profile e 
    ON s.employee_id = e.employee_id
  WHERE s.location_id = $3
)
SELECT shift_id, employee_id, location_id, start_datetime, end_datetime, day, employee_first_name
FROM shift_days
ORDER BY day, start_datetime
`

type GetMonthlySchedulesByLocationParams struct {
	Year       int32 `json:"year"`
	Month      int32 `json:"month"`
	LocationID int64 `json:"location_id"`
}

type GetMonthlySchedulesByLocationRow struct {
	ShiftID           int32            `json:"shift_id"`
	EmployeeID        int64            `json:"employee_id"`
	LocationID        int64            `json:"location_id"`
	StartDatetime     pgtype.Timestamp `json:"start_datetime"`
	EndDatetime       pgtype.Timestamp `json:"end_datetime"`
	Day               pgtype.Date      `json:"day"`
	EmployeeFirstName string           `json:"employee_first_name"`
}

func (q *Queries) GetMonthlySchedulesByLocation(ctx context.Context, arg GetMonthlySchedulesByLocationParams) ([]GetMonthlySchedulesByLocationRow, error) {
	rows, err := q.db.Query(ctx, getMonthlySchedulesByLocation, arg.Year, arg.Month, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlySchedulesByLocationRow
	for rows.Next() {
		var i GetMonthlySchedulesByLocationRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.EmployeeID,
			&i.LocationID,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.Day,
			&i.EmployeeFirstName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
