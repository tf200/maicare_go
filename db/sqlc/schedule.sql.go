// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schedule.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (
    employee_id,
    location_id,
    location_shift_id,
    color,
    is_custom,
    start_datetime,
    end_datetime
) VALUES (
    $1, $2, $3, $4, $5 , $6, $7
)
RETURNING id, employee_id, color, location_id, location_shift_id, is_custom, start_datetime, end_datetime, created_at, updated_at
`

type CreateScheduleParams struct {
	EmployeeID      int64            `json:"employee_id"`
	LocationID      int64            `json:"location_id"`
	LocationShiftID *int64           `json:"location_shift_id"`
	Color           *string          `json:"color"`
	IsCustom        bool             `json:"is_custom"`
	StartDatetime   pgtype.Timestamp `json:"start_datetime"`
	EndDatetime     pgtype.Timestamp `json:"end_datetime"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.EmployeeID,
		arg.LocationID,
		arg.LocationShiftID,
		arg.Color,
		arg.IsCustom,
		arg.StartDatetime,
		arg.EndDatetime,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Color,
		&i.LocationID,
		&i.LocationShiftID,
		&i.IsCustom,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
DELETE FROM schedules
WHERE id = $1
`

func (q *Queries) DeleteSchedule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSchedule, id)
	return err
}

const getDailySchedulesByLocation = `-- name: GetDailySchedulesByLocation :many
WITH target_day AS (
  SELECT make_date($1, $2, $3) AS day
),
shift_days AS (
  SELECT 
    s.id AS shift_id,
    s.employee_id,
    s.location_id,
    s.color,
    s.start_datetime,
    s.end_datetime,
    s.is_custom,
    ls.id AS location_shift_id,
    ls.shift_name,
    d.day,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name
  FROM schedules s
  LEFT JOIN location_shift ls 
    ON s.location_shift_id = ls.id
  JOIN target_day d 
    ON d.day BETWEEN DATE(s.start_datetime) AND DATE(s.end_datetime)
  JOIN employee_profile e 
    ON s.employee_id = e.id
  WHERE s.location_id = $4
)
SELECT shift_id, employee_id, location_id, color, start_datetime, end_datetime, is_custom, location_shift_id, shift_name, day, employee_first_name, employee_last_name
FROM shift_days
ORDER BY start_datetime
`

type GetDailySchedulesByLocationParams struct {
	Year       int32 `json:"year"`
	Month      int32 `json:"month"`
	Day        int32 `json:"day"`
	LocationID int64 `json:"location_id"`
}

type GetDailySchedulesByLocationRow struct {
	ShiftID           uuid.UUID        `json:"shift_id"`
	EmployeeID        int64            `json:"employee_id"`
	LocationID        int64            `json:"location_id"`
	Color             *string          `json:"color"`
	StartDatetime     pgtype.Timestamp `json:"start_datetime"`
	EndDatetime       pgtype.Timestamp `json:"end_datetime"`
	IsCustom          bool             `json:"is_custom"`
	LocationShiftID   *int64           `json:"location_shift_id"`
	ShiftName         *string          `json:"shift_name"`
	Day               pgtype.Date      `json:"day"`
	EmployeeFirstName string           `json:"employee_first_name"`
	EmployeeLastName  string           `json:"employee_last_name"`
}

func (q *Queries) GetDailySchedulesByLocation(ctx context.Context, arg GetDailySchedulesByLocationParams) ([]GetDailySchedulesByLocationRow, error) {
	rows, err := q.db.Query(ctx, getDailySchedulesByLocation,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.LocationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailySchedulesByLocationRow
	for rows.Next() {
		var i GetDailySchedulesByLocationRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.EmployeeID,
			&i.LocationID,
			&i.Color,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.IsCustom,
			&i.LocationShiftID,
			&i.ShiftName,
			&i.Day,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeSchedules = `-- name: GetEmployeeSchedules :many
SELECT 
    s.id,
    s.start_datetime,
    s.end_datetime,
    s.location_id,
    s.color,
    l.name as location_name,
    'shift'::text as type
FROM schedules s
JOIN location l ON s.location_id = l.id
WHERE s.employee_id = $1
    AND s.start_datetime >= $2
    AND s.start_datetime < $3
ORDER BY s.start_datetime
`

type GetEmployeeSchedulesParams struct {
	EmployeeID  int64            `json:"employee_id"`
	PeriodStart pgtype.Timestamp `json:"period_start"`
	PeriodEnd   pgtype.Timestamp `json:"period_end"`
}

type GetEmployeeSchedulesRow struct {
	ID            uuid.UUID        `json:"id"`
	StartDatetime pgtype.Timestamp `json:"start_datetime"`
	EndDatetime   pgtype.Timestamp `json:"end_datetime"`
	LocationID    int64            `json:"location_id"`
	Color         *string          `json:"color"`
	LocationName  string           `json:"location_name"`
	Type          string           `json:"type"`
}

func (q *Queries) GetEmployeeSchedules(ctx context.Context, arg GetEmployeeSchedulesParams) ([]GetEmployeeSchedulesRow, error) {
	rows, err := q.db.Query(ctx, getEmployeeSchedules, arg.EmployeeID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeSchedulesRow
	for rows.Next() {
		var i GetEmployeeSchedulesRow
		if err := rows.Scan(
			&i.ID,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.LocationID,
			&i.Color,
			&i.LocationName,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlySchedulesByLocation = `-- name: GetMonthlySchedulesByLocation :many
WITH target_month AS (
  SELECT make_date($1, $2, 1) AS start_date
)
SELECT 
  s.id AS shift_id,
  s.employee_id,
  s.location_id,
  s.start_datetime,
  s.end_datetime,
  s.color,
  S.is_custom,
  ls.shift_name,
  ls.id AS location_shift_id,
  DATE(s.start_datetime) AS day,
  e.first_name AS employee_first_name,
  e.last_name AS employee_last_name
FROM schedules s
LEFT JOIN location_shift ls 
  ON s.location_shift_id = ls.id
JOIN employee_profile e 
  ON s.employee_id = e.id
WHERE s.location_id = $3
  AND DATE(s.start_datetime) >= (SELECT start_date FROM target_month)
  AND DATE(s.start_datetime) < (SELECT start_date + INTERVAL '1 month' FROM target_month)
ORDER BY DATE(s.start_datetime), s.start_datetime
`

type GetMonthlySchedulesByLocationParams struct {
	Year       int32 `json:"year"`
	Month      int32 `json:"month"`
	LocationID int64 `json:"location_id"`
}

type GetMonthlySchedulesByLocationRow struct {
	ShiftID           uuid.UUID        `json:"shift_id"`
	EmployeeID        int64            `json:"employee_id"`
	LocationID        int64            `json:"location_id"`
	StartDatetime     pgtype.Timestamp `json:"start_datetime"`
	EndDatetime       pgtype.Timestamp `json:"end_datetime"`
	Color             *string          `json:"color"`
	IsCustom          bool             `json:"is_custom"`
	ShiftName         *string          `json:"shift_name"`
	LocationShiftID   *int64           `json:"location_shift_id"`
	Day               pgtype.Date      `json:"day"`
	EmployeeFirstName string           `json:"employee_first_name"`
	EmployeeLastName  string           `json:"employee_last_name"`
}

func (q *Queries) GetMonthlySchedulesByLocation(ctx context.Context, arg GetMonthlySchedulesByLocationParams) ([]GetMonthlySchedulesByLocationRow, error) {
	rows, err := q.db.Query(ctx, getMonthlySchedulesByLocation, arg.Year, arg.Month, arg.LocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlySchedulesByLocationRow
	for rows.Next() {
		var i GetMonthlySchedulesByLocationRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.EmployeeID,
			&i.LocationID,
			&i.StartDatetime,
			&i.EndDatetime,
			&i.Color,
			&i.IsCustom,
			&i.ShiftName,
			&i.LocationShiftID,
			&i.Day,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleById = `-- name: GetScheduleById :one
SELECT s.id, s.employee_id, s.color, s.location_id, s.location_shift_id, s.is_custom, s.start_datetime, s.end_datetime, s.created_at, s.updated_at,
    e.first_name AS employee_first_name,
    e.last_name AS employee_last_name,
    l.name AS location_name,
    ls.shift_name AS location_shift_name,
    ls.id AS location_shift_id
FROM schedules s
LEFT JOIN location_shift ls ON s.location_shift_id = ls.id
JOIN employee_profile e ON s.employee_id = e.id
JOIN location l ON s.location_id = l.id
WHERE s.id = $1
LIMIT 1
`

type GetScheduleByIdRow struct {
	ID                uuid.UUID        `json:"id"`
	EmployeeID        int64            `json:"employee_id"`
	Color             *string          `json:"color"`
	LocationID        int64            `json:"location_id"`
	LocationShiftID   *int64           `json:"location_shift_id"`
	IsCustom          bool             `json:"is_custom"`
	StartDatetime     pgtype.Timestamp `json:"start_datetime"`
	EndDatetime       pgtype.Timestamp `json:"end_datetime"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	EmployeeFirstName string           `json:"employee_first_name"`
	EmployeeLastName  string           `json:"employee_last_name"`
	LocationName      string           `json:"location_name"`
	LocationShiftName *string          `json:"location_shift_name"`
	LocationShiftID_2 *int64           `json:"location_shift_id_2"`
}

func (q *Queries) GetScheduleById(ctx context.Context, id uuid.UUID) (GetScheduleByIdRow, error) {
	row := q.db.QueryRow(ctx, getScheduleById, id)
	var i GetScheduleByIdRow
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Color,
		&i.LocationID,
		&i.LocationShiftID,
		&i.IsCustom,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmployeeFirstName,
		&i.EmployeeLastName,
		&i.LocationName,
		&i.LocationShiftName,
		&i.LocationShiftID_2,
	)
	return i, err
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules
SET
    employee_id = $2,
    location_id = $3,
    location_shift_id = $4,
    color = $5,
    start_datetime = $6,
    end_datetime = $7
WHERE id = $1
RETURNING id, employee_id, color, location_id, location_shift_id, is_custom, start_datetime, end_datetime, created_at, updated_at
`

type UpdateScheduleParams struct {
	ID              uuid.UUID        `json:"id"`
	EmployeeID      int64            `json:"employee_id"`
	LocationID      int64            `json:"location_id"`
	LocationShiftID *int64           `json:"location_shift_id"`
	Color           *string          `json:"color"`
	StartDatetime   pgtype.Timestamp `json:"start_datetime"`
	EndDatetime     pgtype.Timestamp `json:"end_datetime"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.db.QueryRow(ctx, updateSchedule,
		arg.ID,
		arg.EmployeeID,
		arg.LocationID,
		arg.LocationShiftID,
		arg.Color,
		arg.StartDatetime,
		arg.EndDatetime,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Color,
		&i.LocationID,
		&i.LocationShiftID,
		&i.IsCustom,
		&i.StartDatetime,
		&i.EndDatetime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
