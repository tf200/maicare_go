// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: client_medical.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientAllergy = `-- name: CreateClientAllergy :one
INSERT INTO client_allergy (
    client_id,
    allergy_type,
    severity,
    reaction,
    notes,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, client_id, allergy_type, severity, reaction, notes, created_at
`

type CreateClientAllergyParams struct {
	ClientID    int64              `json:"client_id"`
	AllergyType string             `json:"allergy_type"`
	Severity    string             `json:"severity"`
	Reaction    string             `json:"reaction"`
	Notes       *string            `json:"notes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateClientAllergy(ctx context.Context, arg CreateClientAllergyParams) (ClientAllergy, error) {
	row := q.db.QueryRow(ctx, createClientAllergy,
		arg.ClientID,
		arg.AllergyType,
		arg.Severity,
		arg.Reaction,
		arg.Notes,
		arg.CreatedAt,
	)
	var i ClientAllergy
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.AllergyType,
		&i.Severity,
		&i.Reaction,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createClientDiagnosis = `-- name: CreateClientDiagnosis :one
INSERT INTO client_diagnosis (
    client_id,
    title,
    diagnosis_code,
    description,
    severity,
    status,
    diagnosing_clinician,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

type CreateClientDiagnosisParams struct {
	ClientID            int64   `json:"client_id"`
	Title               *string `json:"title"`
	DiagnosisCode       string  `json:"diagnosis_code"`
	Description         string  `json:"description"`
	Severity            *string `json:"severity"`
	Status              string  `json:"status"`
	DiagnosingClinician *string `json:"diagnosing_clinician"`
	Notes               *string `json:"notes"`
}

func (q *Queries) CreateClientDiagnosis(ctx context.Context, arg CreateClientDiagnosisParams) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, createClientDiagnosis,
		arg.ClientID,
		arg.Title,
		arg.DiagnosisCode,
		arg.Description,
		arg.Severity,
		arg.Status,
		arg.DiagnosingClinician,
		arg.Notes,
	)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createClientMedication = `-- name: CreateClientMedication :one
INSERT INTO client_medication (
    name,
    dosage,
    start_date,
    end_date,
    notes,
    self_administered,
    client_id,
    administered_by_id,
    is_critical
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, dosage, start_date, end_date, notes, self_administered, slots, client_id, administered_by_id, is_critical, updated_at, created_at
`

type CreateClientMedicationParams struct {
	Name             string      `json:"name"`
	Dosage           string      `json:"dosage"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	Notes            *string     `json:"notes"`
	SelfAdministered bool        `json:"self_administered"`
	ClientID         int64       `json:"client_id"`
	AdministeredByID *int64      `json:"administered_by_id"`
	IsCritical       bool        `json:"is_critical"`
}

func (q *Queries) CreateClientMedication(ctx context.Context, arg CreateClientMedicationParams) (ClientMedication, error) {
	row := q.db.QueryRow(ctx, createClientMedication,
		arg.Name,
		arg.Dosage,
		arg.StartDate,
		arg.EndDate,
		arg.Notes,
		arg.SelfAdministered,
		arg.ClientID,
		arg.AdministeredByID,
		arg.IsCritical,
	)
	var i ClientMedication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.ClientID,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClientAllergy = `-- name: DeleteClientAllergy :one
DELETE FROM client_allergy
WHERE id = $1
RETURNING id, client_id, allergy_type, severity, reaction, notes, created_at
`

func (q *Queries) DeleteClientAllergy(ctx context.Context, id int64) (ClientAllergy, error) {
	row := q.db.QueryRow(ctx, deleteClientAllergy, id)
	var i ClientAllergy
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.AllergyType,
		&i.Severity,
		&i.Reaction,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClientDiagnosis = `-- name: DeleteClientDiagnosis :one
DELETE FROM client_diagnosis
WHERE id = $1  
RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

func (q *Queries) DeleteClientDiagnosis(ctx context.Context, id int64) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, deleteClientDiagnosis, id)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClientMedication = `-- name: DeleteClientMedication :one
DELETE FROM client_medication
WHERE id = $1
RETURNING id, name, dosage, start_date, end_date, notes, self_administered, slots, client_id, administered_by_id, is_critical, updated_at, created_at
`

func (q *Queries) DeleteClientMedication(ctx context.Context, id int64) (ClientMedication, error) {
	row := q.db.QueryRow(ctx, deleteClientMedication, id)
	var i ClientMedication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.ClientID,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getClientAllergy = `-- name: GetClientAllergy :one
SELECT id, client_id, allergy_type, severity, reaction, notes, created_at FROM client_allergy
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetClientAllergy(ctx context.Context, id int64) (ClientAllergy, error) {
	row := q.db.QueryRow(ctx, getClientAllergy, id)
	var i ClientAllergy
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.AllergyType,
		&i.Severity,
		&i.Reaction,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getClientDiagnosis = `-- name: GetClientDiagnosis :one
SELECT id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at FROM client_diagnosis
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetClientDiagnosis(ctx context.Context, id int64) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, getClientDiagnosis, id)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getClientMedication = `-- name: GetClientMedication :one
SELECT m.id, m.name, m.dosage, m.start_date, m.end_date, m.notes, m.self_administered, m.slots, m.client_id, m.administered_by_id, m.is_critical, m.updated_at, m.created_at, e.first_name AS administered_by_first_name, e.last_name AS administered_by_last_name
FROM client_medication m
JOIN employee_profile e ON m.administered_by_id = e.id
WHERE m.id = $1 LIMIT 1
`

type GetClientMedicationRow struct {
	ID                      int64              `json:"id"`
	Name                    string             `json:"name"`
	Dosage                  string             `json:"dosage"`
	StartDate               pgtype.Date        `json:"start_date"`
	EndDate                 pgtype.Date        `json:"end_date"`
	Notes                   *string            `json:"notes"`
	SelfAdministered        bool               `json:"self_administered"`
	Slots                   []byte             `json:"slots"`
	ClientID                int64              `json:"client_id"`
	AdministeredByID        *int64             `json:"administered_by_id"`
	IsCritical              bool               `json:"is_critical"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	AdministeredByFirstName string             `json:"administered_by_first_name"`
	AdministeredByLastName  string             `json:"administered_by_last_name"`
}

func (q *Queries) GetClientMedication(ctx context.Context, id int64) (GetClientMedicationRow, error) {
	row := q.db.QueryRow(ctx, getClientMedication, id)
	var i GetClientMedicationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.ClientID,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.AdministeredByFirstName,
		&i.AdministeredByLastName,
	)
	return i, err
}

const listClientAllergies = `-- name: ListClientAllergies :many
SELECT 
    al.id, al.client_id, al.allergy_type, al.severity, al.reaction, al.notes, al.created_at,
    (SELECT COUNT(*) FROM client_allergy WHERE client_allergy.client_id = al.client_id) AS total_allergies
FROM client_allergy al
WHERE al.client_id = $1
LIMIT $2 OFFSET $3
`

type ListClientAllergiesParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientAllergiesRow struct {
	ID             int64              `json:"id"`
	ClientID       int64              `json:"client_id"`
	AllergyType    string             `json:"allergy_type"`
	Severity       string             `json:"severity"`
	Reaction       string             `json:"reaction"`
	Notes          *string            `json:"notes"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	TotalAllergies int64              `json:"total_allergies"`
}

func (q *Queries) ListClientAllergies(ctx context.Context, arg ListClientAllergiesParams) ([]ListClientAllergiesRow, error) {
	rows, err := q.db.Query(ctx, listClientAllergies, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientAllergiesRow
	for rows.Next() {
		var i ListClientAllergiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.AllergyType,
			&i.Severity,
			&i.Reaction,
			&i.Notes,
			&i.CreatedAt,
			&i.TotalAllergies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientDiagnoses = `-- name: ListClientDiagnoses :many
SELECT 
    d.id, d.title, d.client_id, d.diagnosis_code, d.description, d.severity, d.status, d.diagnosing_clinician, d.notes, d.created_at,
    (SELECT COUNT(*) FROM client_diagnosis WHERE client_diagnosis.client_id = d.client_id) AS total_diagnoses
FROM client_diagnosis d
WHERE d.client_id = $1
LIMIT $2 OFFSET $3
`

type ListClientDiagnosesParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientDiagnosesRow struct {
	ID                  int64              `json:"id"`
	Title               *string            `json:"title"`
	ClientID            int64              `json:"client_id"`
	DiagnosisCode       string             `json:"diagnosis_code"`
	Description         string             `json:"description"`
	Severity            *string            `json:"severity"`
	Status              string             `json:"status"`
	DiagnosingClinician *string            `json:"diagnosing_clinician"`
	Notes               *string            `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	TotalDiagnoses      int64              `json:"total_diagnoses"`
}

func (q *Queries) ListClientDiagnoses(ctx context.Context, arg ListClientDiagnosesParams) ([]ListClientDiagnosesRow, error) {
	rows, err := q.db.Query(ctx, listClientDiagnoses, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientDiagnosesRow
	for rows.Next() {
		var i ListClientDiagnosesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ClientID,
			&i.DiagnosisCode,
			&i.Description,
			&i.Severity,
			&i.Status,
			&i.DiagnosingClinician,
			&i.Notes,
			&i.CreatedAt,
			&i.TotalDiagnoses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClientMedications = `-- name: ListClientMedications :many
SELECT 
    m.id, m.name, m.dosage, m.start_date, m.end_date, m.notes, m.self_administered, m.slots, m.client_id, m.administered_by_id, m.is_critical, m.updated_at, m.created_at,
    e.first_name AS administered_by_first_name,
    e.last_name AS administered_by_last_name,
    (SELECT COUNT(*) FROM client_medication WHERE client_medication.client_id = m.client_id) AS total_medications
FROM client_medication m
JOIN employee_profile e ON m.administered_by_id = e.id
WHERE m.client_id = $1
LIMIT $2 OFFSET $3
`

type ListClientMedicationsParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientMedicationsRow struct {
	ID                      int64              `json:"id"`
	Name                    string             `json:"name"`
	Dosage                  string             `json:"dosage"`
	StartDate               pgtype.Date        `json:"start_date"`
	EndDate                 pgtype.Date        `json:"end_date"`
	Notes                   *string            `json:"notes"`
	SelfAdministered        bool               `json:"self_administered"`
	Slots                   []byte             `json:"slots"`
	ClientID                int64              `json:"client_id"`
	AdministeredByID        *int64             `json:"administered_by_id"`
	IsCritical              bool               `json:"is_critical"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	AdministeredByFirstName string             `json:"administered_by_first_name"`
	AdministeredByLastName  string             `json:"administered_by_last_name"`
	TotalMedications        int64              `json:"total_medications"`
}

func (q *Queries) ListClientMedications(ctx context.Context, arg ListClientMedicationsParams) ([]ListClientMedicationsRow, error) {
	rows, err := q.db.Query(ctx, listClientMedications, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientMedicationsRow
	for rows.Next() {
		var i ListClientMedicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Dosage,
			&i.StartDate,
			&i.EndDate,
			&i.Notes,
			&i.SelfAdministered,
			&i.Slots,
			&i.ClientID,
			&i.AdministeredByID,
			&i.IsCritical,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.AdministeredByFirstName,
			&i.AdministeredByLastName,
			&i.TotalMedications,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientAllergy = `-- name: UpdateClientAllergy :one
UPDATE client_allergy
SET
    allergy_type = COALESCE($2, allergy_type),
    severity = COALESCE($3, severity),
    reaction = COALESCE($4, reaction),
    notes = COALESCE($5, notes)
WHERE id = $1
RETURNING id, client_id, allergy_type, severity, reaction, notes, created_at
`

type UpdateClientAllergyParams struct {
	ID          int64   `json:"id"`
	AllergyType *string `json:"allergy_type"`
	Severity    *string `json:"severity"`
	Reaction    *string `json:"reaction"`
	Notes       *string `json:"notes"`
}

func (q *Queries) UpdateClientAllergy(ctx context.Context, arg UpdateClientAllergyParams) (ClientAllergy, error) {
	row := q.db.QueryRow(ctx, updateClientAllergy,
		arg.ID,
		arg.AllergyType,
		arg.Severity,
		arg.Reaction,
		arg.Notes,
	)
	var i ClientAllergy
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.AllergyType,
		&i.Severity,
		&i.Reaction,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const updateClientDiagnosis = `-- name: UpdateClientDiagnosis :one
UPDATE client_diagnosis
SET
    title = COALESCE($2, title),
    diagnosis_code = COALESCE($3, diagnosis_code),
    description = COALESCE($4, description),
    severity = COALESCE($5, severity),
    status = COALESCE($6, status),
    diagnosing_clinician = COALESCE($7, diagnosing_clinician),
    notes = COALESCE($8, notes)
WHERE id = $1
RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

type UpdateClientDiagnosisParams struct {
	ID                  int64   `json:"id"`
	Title               *string `json:"title"`
	DiagnosisCode       *string `json:"diagnosis_code"`
	Description         *string `json:"description"`
	Severity            *string `json:"severity"`
	Status              *string `json:"status"`
	DiagnosingClinician *string `json:"diagnosing_clinician"`
	Notes               *string `json:"notes"`
}

func (q *Queries) UpdateClientDiagnosis(ctx context.Context, arg UpdateClientDiagnosisParams) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, updateClientDiagnosis,
		arg.ID,
		arg.Title,
		arg.DiagnosisCode,
		arg.Description,
		arg.Severity,
		arg.Status,
		arg.DiagnosingClinician,
		arg.Notes,
	)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const updateClientMedication = `-- name: UpdateClientMedication :one
UPDATE client_medication
SET
    name = COALESCE($2, name),
    dosage = COALESCE($3, dosage),
    start_date = COALESCE($4, start_date),
    end_date = COALESCE($5, end_date),
    notes = COALESCE($6, notes),
    self_administered = COALESCE($7, self_administered),
    administered_by_id = COALESCE($8, administered_by_id),
    is_critical = COALESCE($9, is_critical)
WHERE id = $1
RETURNING id, name, dosage, start_date, end_date, notes, self_administered, slots, client_id, administered_by_id, is_critical, updated_at, created_at
`

type UpdateClientMedicationParams struct {
	ID               int64       `json:"id"`
	Name             *string     `json:"name"`
	Dosage           *string     `json:"dosage"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	Notes            *string     `json:"notes"`
	SelfAdministered *bool       `json:"self_administered"`
	AdministeredByID *int64      `json:"administered_by_id"`
	IsCritical       *bool       `json:"is_critical"`
}

func (q *Queries) UpdateClientMedication(ctx context.Context, arg UpdateClientMedicationParams) (ClientMedication, error) {
	row := q.db.QueryRow(ctx, updateClientMedication,
		arg.ID,
		arg.Name,
		arg.Dosage,
		arg.StartDate,
		arg.EndDate,
		arg.Notes,
		arg.SelfAdministered,
		arg.AdministeredByID,
		arg.IsCritical,
	)
	var i ClientMedication
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.ClientID,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
