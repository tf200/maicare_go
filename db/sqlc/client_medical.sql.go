// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: client_medical.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientDiagnosis = `-- name: CreateClientDiagnosis :one
INSERT INTO client_diagnosis (
    client_id,
    title,
    diagnosis_code,
    description,
    severity,
    status,
    diagnosing_clinician,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

type CreateClientDiagnosisParams struct {
	ClientID            int64   `json:"client_id"`
	Title               *string `json:"title"`
	DiagnosisCode       string  `json:"diagnosis_code"`
	Description         string  `json:"description"`
	Severity            *string `json:"severity"`
	Status              string  `json:"status"`
	DiagnosingClinician *string `json:"diagnosing_clinician"`
	Notes               *string `json:"notes"`
}

func (q *Queries) CreateClientDiagnosis(ctx context.Context, arg CreateClientDiagnosisParams) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, createClientDiagnosis,
		arg.ClientID,
		arg.Title,
		arg.DiagnosisCode,
		arg.Description,
		arg.Severity,
		arg.Status,
		arg.DiagnosingClinician,
		arg.Notes,
	)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createClientMedication = `-- name: CreateClientMedication :one
INSERT INTO client_medication (
    diagnosis_id,
    name,
    dosage,
    start_date,
    end_date,
    notes,
    self_administered,
    administered_by_id,
    is_critical
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, diagnosis_id, name, dosage, start_date, end_date, notes, self_administered, slots, administered_by_id, is_critical, updated_at, created_at
`

type CreateClientMedicationParams struct {
	DiagnosisID      *int64      `json:"diagnosis_id"`
	Name             string      `json:"name"`
	Dosage           string      `json:"dosage"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	Notes            *string     `json:"notes"`
	SelfAdministered bool        `json:"self_administered"`
	AdministeredByID *int64      `json:"administered_by_id"`
	IsCritical       bool        `json:"is_critical"`
}

func (q *Queries) CreateClientMedication(ctx context.Context, arg CreateClientMedicationParams) (ClientMedication, error) {
	row := q.db.QueryRow(ctx, createClientMedication,
		arg.DiagnosisID,
		arg.Name,
		arg.Dosage,
		arg.StartDate,
		arg.EndDate,
		arg.Notes,
		arg.SelfAdministered,
		arg.AdministeredByID,
		arg.IsCritical,
	)
	var i ClientMedication
	err := row.Scan(
		&i.ID,
		&i.DiagnosisID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClientDiagnosis = `-- name: DeleteClientDiagnosis :one
DELETE FROM client_diagnosis
WHERE id = $1  
RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

func (q *Queries) DeleteClientDiagnosis(ctx context.Context, id int64) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, deleteClientDiagnosis, id)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteClientMedication = `-- name: DeleteClientMedication :exec
DELETE FROM client_medication
WHERE id = $1
`

func (q *Queries) DeleteClientMedication(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteClientMedication, id)
	return err
}

const getClientDiagnosis = `-- name: GetClientDiagnosis :one
SELECT id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at FROM client_diagnosis
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetClientDiagnosis(ctx context.Context, id int64) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, getClientDiagnosis, id)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getMedication = `-- name: GetMedication :one
SELECT m.id, m.diagnosis_id, m.name, m.dosage, m.start_date, m.end_date, m.notes, m.self_administered, m.slots, m.administered_by_id, m.is_critical, m.updated_at, m.created_at, e.first_name AS administered_by_first_name, e.last_name AS administered_by_last_name
FROM client_medication m
JOIN employee_profile e ON m.administered_by_id = e.id
WHERE m.id = $1 LIMIT 1
`

type GetMedicationRow struct {
	ID                      int64              `json:"id"`
	DiagnosisID             *int64             `json:"diagnosis_id"`
	Name                    string             `json:"name"`
	Dosage                  string             `json:"dosage"`
	StartDate               pgtype.Date        `json:"start_date"`
	EndDate                 pgtype.Date        `json:"end_date"`
	Notes                   *string            `json:"notes"`
	SelfAdministered        bool               `json:"self_administered"`
	Slots                   []byte             `json:"slots"`
	AdministeredByID        *int64             `json:"administered_by_id"`
	IsCritical              bool               `json:"is_critical"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	AdministeredByFirstName string             `json:"administered_by_first_name"`
	AdministeredByLastName  string             `json:"administered_by_last_name"`
}

func (q *Queries) GetMedication(ctx context.Context, id int64) (GetMedicationRow, error) {
	row := q.db.QueryRow(ctx, getMedication, id)
	var i GetMedicationRow
	err := row.Scan(
		&i.ID,
		&i.DiagnosisID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.AdministeredByFirstName,
		&i.AdministeredByLastName,
	)
	return i, err
}

const listClientDiagnoses = `-- name: ListClientDiagnoses :many
SELECT 
    d.id, d.title, d.client_id, d.diagnosis_code, d.description, d.severity, d.status, d.diagnosing_clinician, d.notes, d.created_at,
    (SELECT COUNT(*) FROM client_diagnosis WHERE client_diagnosis.client_id = d.client_id) AS total_diagnoses
FROM client_diagnosis d
WHERE d.client_id = $1
LIMIT $2 OFFSET $3
`

type ListClientDiagnosesParams struct {
	ClientID int64 `json:"client_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type ListClientDiagnosesRow struct {
	ID                  int64              `json:"id"`
	Title               *string            `json:"title"`
	ClientID            int64              `json:"client_id"`
	DiagnosisCode       string             `json:"diagnosis_code"`
	Description         string             `json:"description"`
	Severity            *string            `json:"severity"`
	Status              string             `json:"status"`
	DiagnosingClinician *string            `json:"diagnosing_clinician"`
	Notes               *string            `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	TotalDiagnoses      int64              `json:"total_diagnoses"`
}

func (q *Queries) ListClientDiagnoses(ctx context.Context, arg ListClientDiagnosesParams) ([]ListClientDiagnosesRow, error) {
	rows, err := q.db.Query(ctx, listClientDiagnoses, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClientDiagnosesRow
	for rows.Next() {
		var i ListClientDiagnosesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ClientID,
			&i.DiagnosisCode,
			&i.Description,
			&i.Severity,
			&i.Status,
			&i.DiagnosingClinician,
			&i.Notes,
			&i.CreatedAt,
			&i.TotalDiagnoses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedicationsByDiagnosisID = `-- name: ListMedicationsByDiagnosisID :many
SELECT 
    m.id, m.diagnosis_id, m.name, m.dosage, m.start_date, m.end_date, m.notes, m.self_administered, m.slots, m.administered_by_id, m.is_critical, m.updated_at, m.created_at,
    (SELECT COUNT(*) FROM client_medication WHERE client_medication.diagnosis_id = $1) AS total_medications
FROM client_medication m
WHERE m.diagnosis_id = $1
ORDER BY m.id
LIMIT $2 OFFSET $3
`

type ListMedicationsByDiagnosisIDParams struct {
	DiagnosisID *int64 `json:"diagnosis_id"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type ListMedicationsByDiagnosisIDRow struct {
	ID               int64              `json:"id"`
	DiagnosisID      *int64             `json:"diagnosis_id"`
	Name             string             `json:"name"`
	Dosage           string             `json:"dosage"`
	StartDate        pgtype.Date        `json:"start_date"`
	EndDate          pgtype.Date        `json:"end_date"`
	Notes            *string            `json:"notes"`
	SelfAdministered bool               `json:"self_administered"`
	Slots            []byte             `json:"slots"`
	AdministeredByID *int64             `json:"administered_by_id"`
	IsCritical       bool               `json:"is_critical"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	TotalMedications int64              `json:"total_medications"`
}

func (q *Queries) ListMedicationsByDiagnosisID(ctx context.Context, arg ListMedicationsByDiagnosisIDParams) ([]ListMedicationsByDiagnosisIDRow, error) {
	rows, err := q.db.Query(ctx, listMedicationsByDiagnosisID, arg.DiagnosisID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMedicationsByDiagnosisIDRow
	for rows.Next() {
		var i ListMedicationsByDiagnosisIDRow
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosisID,
			&i.Name,
			&i.Dosage,
			&i.StartDate,
			&i.EndDate,
			&i.Notes,
			&i.SelfAdministered,
			&i.Slots,
			&i.AdministeredByID,
			&i.IsCritical,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.TotalMedications,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedicationsByDiagnosisIDs = `-- name: ListMedicationsByDiagnosisIDs :many
SELECT id, diagnosis_id, name, dosage, start_date, end_date, notes, self_administered, slots, administered_by_id, is_critical, updated_at, created_at
FROM client_medication
WHERE diagnosis_id = ANY($1::bigint[])
`

func (q *Queries) ListMedicationsByDiagnosisIDs(ctx context.Context, dollar_1 []int64) ([]ClientMedication, error) {
	rows, err := q.db.Query(ctx, listMedicationsByDiagnosisIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientMedication
	for rows.Next() {
		var i ClientMedication
		if err := rows.Scan(
			&i.ID,
			&i.DiagnosisID,
			&i.Name,
			&i.Dosage,
			&i.StartDate,
			&i.EndDate,
			&i.Notes,
			&i.SelfAdministered,
			&i.Slots,
			&i.AdministeredByID,
			&i.IsCritical,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientDiagnosis = `-- name: UpdateClientDiagnosis :one
UPDATE client_diagnosis
SET
    title = COALESCE($2, title),
    diagnosis_code = COALESCE($3, diagnosis_code),
    description = COALESCE($4, description),
    severity = COALESCE($5, severity),
    status = COALESCE($6, status),
    diagnosing_clinician = COALESCE($7, diagnosing_clinician),
    notes = COALESCE($8, notes)
WHERE id = $1
RETURNING id, title, client_id, diagnosis_code, description, severity, status, diagnosing_clinician, notes, created_at
`

type UpdateClientDiagnosisParams struct {
	ID                  int64   `json:"id"`
	Title               *string `json:"title"`
	DiagnosisCode       *string `json:"diagnosis_code"`
	Description         *string `json:"description"`
	Severity            *string `json:"severity"`
	Status              *string `json:"status"`
	DiagnosingClinician *string `json:"diagnosing_clinician"`
	Notes               *string `json:"notes"`
}

func (q *Queries) UpdateClientDiagnosis(ctx context.Context, arg UpdateClientDiagnosisParams) (ClientDiagnosis, error) {
	row := q.db.QueryRow(ctx, updateClientDiagnosis,
		arg.ID,
		arg.Title,
		arg.DiagnosisCode,
		arg.Description,
		arg.Severity,
		arg.Status,
		arg.DiagnosingClinician,
		arg.Notes,
	)
	var i ClientDiagnosis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ClientID,
		&i.DiagnosisCode,
		&i.Description,
		&i.Severity,
		&i.Status,
		&i.DiagnosingClinician,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const updateClientMedication = `-- name: UpdateClientMedication :one
UPDATE client_medication
SET
    name = COALESCE($2, name),
    dosage = COALESCE($3, dosage),
    start_date = COALESCE($4, start_date),
    end_date = COALESCE($5, end_date),
    notes = COALESCE($6, notes),
    self_administered = COALESCE($7, self_administered),
    administered_by_id = COALESCE($8, administered_by_id),
    is_critical = COALESCE($9, is_critical)
WHERE id = $1
RETURNING id, diagnosis_id, name, dosage, start_date, end_date, notes, self_administered, slots, administered_by_id, is_critical, updated_at, created_at
`

type UpdateClientMedicationParams struct {
	ID               int64       `json:"id"`
	Name             *string     `json:"name"`
	Dosage           *string     `json:"dosage"`
	StartDate        pgtype.Date `json:"start_date"`
	EndDate          pgtype.Date `json:"end_date"`
	Notes            *string     `json:"notes"`
	SelfAdministered *bool       `json:"self_administered"`
	AdministeredByID *int64      `json:"administered_by_id"`
	IsCritical       *bool       `json:"is_critical"`
}

func (q *Queries) UpdateClientMedication(ctx context.Context, arg UpdateClientMedicationParams) (ClientMedication, error) {
	row := q.db.QueryRow(ctx, updateClientMedication,
		arg.ID,
		arg.Name,
		arg.Dosage,
		arg.StartDate,
		arg.EndDate,
		arg.Notes,
		arg.SelfAdministered,
		arg.AdministeredByID,
		arg.IsCritical,
	)
	var i ClientMedication
	err := row.Scan(
		&i.ID,
		&i.DiagnosisID,
		&i.Name,
		&i.Dosage,
		&i.StartDate,
		&i.EndDate,
		&i.Notes,
		&i.SelfAdministered,
		&i.Slots,
		&i.AdministeredByID,
		&i.IsCritical,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
