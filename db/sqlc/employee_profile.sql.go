// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: employee_profile.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEmployeeProfile = `-- name: CountEmployeeProfile :one
SELECT COUNT(*) 
FROM employee_profile ep
WHERE 
    (CASE 
        WHEN $1::boolean IS NULL THEN true
        WHEN $1::boolean = false THEN NOT ep.is_archived
        ELSE true
    END) AND
    (CASE 
        WHEN $2::boolean IS NULL THEN true
        WHEN $2::boolean = false THEN NOT COALESCE(ep.out_of_service, false)
        ELSE true
    END) AND
    (department = $3 OR $3 IS NULL) AND
    (position = $4 OR $4 IS NULL) AND
    (location_id = $5 OR $5 IS NULL)
`

type CountEmployeeProfileParams struct {
	IncludeArchived     *bool   `json:"include_archived"`
	IncludeOutOfService *bool   `json:"include_out_of_service"`
	Department          *string `json:"department"`
	Position            *string `json:"position"`
	LocationID          *int64  `json:"location_id"`
}

func (q *Queries) CountEmployeeProfile(ctx context.Context, arg CountEmployeeProfileParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployeeProfile,
		arg.IncludeArchived,
		arg.IncludeOutOfService,
		arg.Department,
		arg.Position,
		arg.LocationID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmployeeProfile = `-- name: CreateEmployeeProfile :one
INSERT INTO employee_profile (
    user_id,
    first_name,
    last_name,
    position,
    department,
    employee_number,
    employment_number,
    private_email_address,
    email,
    authentication_phone_number,
    private_phone_number,
    work_phone_number,
    date_of_birth,
    home_telephone_number,
    is_subcontractor,
    gender,
    location_id,
    has_borrowed,
    out_of_service,
    is_archived
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
) RETURNING id, user_id, first_name, last_name, position, department, employee_number, employment_number, private_email_address, email, authentication_phone_number, private_phone_number, work_phone_number, date_of_birth, home_telephone_number, created, is_subcontractor, gender, location_id, has_borrowed, out_of_service, is_archived
`

type CreateEmployeeProfileParams struct {
	UserID                    int64       `json:"user_id"`
	FirstName                 string      `json:"first_name"`
	LastName                  string      `json:"last_name"`
	Position                  *string     `json:"position"`
	Department                *string     `json:"department"`
	EmployeeNumber            *string     `json:"employee_number"`
	EmploymentNumber          *string     `json:"employment_number"`
	PrivateEmailAddress       *string     `json:"private_email_address"`
	Email                     string      `json:"email"`
	AuthenticationPhoneNumber *string     `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string     `json:"private_phone_number"`
	WorkPhoneNumber           *string     `json:"work_phone_number"`
	DateOfBirth               pgtype.Date `json:"date_of_birth"`
	HomeTelephoneNumber       *string     `json:"home_telephone_number"`
	IsSubcontractor           *bool       `json:"is_subcontractor"`
	Gender                    *string     `json:"gender"`
	LocationID                *int64      `json:"location_id"`
	HasBorrowed               bool        `json:"has_borrowed"`
	OutOfService              *bool       `json:"out_of_service"`
	IsArchived                bool        `json:"is_archived"`
}

func (q *Queries) CreateEmployeeProfile(ctx context.Context, arg CreateEmployeeProfileParams) (EmployeeProfile, error) {
	row := q.db.QueryRow(ctx, createEmployeeProfile,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.Position,
		arg.Department,
		arg.EmployeeNumber,
		arg.EmploymentNumber,
		arg.PrivateEmailAddress,
		arg.Email,
		arg.AuthenticationPhoneNumber,
		arg.PrivatePhoneNumber,
		arg.WorkPhoneNumber,
		arg.DateOfBirth,
		arg.HomeTelephoneNumber,
		arg.IsSubcontractor,
		arg.Gender,
		arg.LocationID,
		arg.HasBorrowed,
		arg.OutOfService,
		arg.IsArchived,
	)
	var i EmployeeProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Position,
		&i.Department,
		&i.EmployeeNumber,
		&i.EmploymentNumber,
		&i.PrivateEmailAddress,
		&i.Email,
		&i.AuthenticationPhoneNumber,
		&i.PrivatePhoneNumber,
		&i.WorkPhoneNumber,
		&i.DateOfBirth,
		&i.HomeTelephoneNumber,
		&i.Created,
		&i.IsSubcontractor,
		&i.Gender,
		&i.LocationID,
		&i.HasBorrowed,
		&i.OutOfService,
		&i.IsArchived,
	)
	return i, err
}

const listEmployeeProfile = `-- name: ListEmployeeProfile :many
SELECT 
    ep.id, ep.user_id, ep.first_name, ep.last_name, ep.position, ep.department, ep.employee_number, ep.employment_number, ep.private_email_address, ep.email, ep.authentication_phone_number, ep.private_phone_number, ep.work_phone_number, ep.date_of_birth, ep.home_telephone_number, ep.created, ep.is_subcontractor, ep.gender, ep.location_id, ep.has_borrowed, ep.out_of_service, ep.is_archived,
    u.profile_picture as profile_picture
FROM employee_profile ep
JOIN custom_user u ON ep.user_id = u.id
WHERE 
    (CASE 
        WHEN $3::boolean IS NULL THEN true
        WHEN $3::boolean = false THEN NOT ep.is_archived
        ELSE true
    END) AND
    (CASE 
        WHEN $4::boolean IS NULL THEN true
        WHEN $4::boolean = false THEN NOT COALESCE(ep.out_of_service, false)
        ELSE true
    END) AND
    (ep.department = $5 OR $5 IS NULL) AND
    (ep.position = $6 OR $6 IS NULL) AND
    (ep.location_id = $7 OR $7 IS NULL) AND
    ($8::TEXT IS NULL OR 
        ep.first_name ILIKE '%' || $8 || '%' OR 
        ep.last_name ILIKE '%' || $8 || '%')
ORDER BY ep.created DESC
LIMIT $1 OFFSET $2
`

type ListEmployeeProfileParams struct {
	Limit               int32   `json:"limit"`
	Offset              int32   `json:"offset"`
	IncludeArchived     *bool   `json:"include_archived"`
	IncludeOutOfService *bool   `json:"include_out_of_service"`
	Department          *string `json:"department"`
	Position            *string `json:"position"`
	LocationID          *int64  `json:"location_id"`
	Search              *string `json:"search"`
}

type ListEmployeeProfileRow struct {
	ID                        int64              `json:"id"`
	UserID                    int64              `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	Position                  *string            `json:"position"`
	Department                *string            `json:"department"`
	EmployeeNumber            *string            `json:"employee_number"`
	EmploymentNumber          *string            `json:"employment_number"`
	PrivateEmailAddress       *string            `json:"private_email_address"`
	Email                     string             `json:"email"`
	AuthenticationPhoneNumber *string            `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string            `json:"private_phone_number"`
	WorkPhoneNumber           *string            `json:"work_phone_number"`
	DateOfBirth               pgtype.Date        `json:"date_of_birth"`
	HomeTelephoneNumber       *string            `json:"home_telephone_number"`
	Created                   pgtype.Timestamptz `json:"created"`
	IsSubcontractor           *bool              `json:"is_subcontractor"`
	Gender                    *string            `json:"gender"`
	LocationID                *int64             `json:"location_id"`
	HasBorrowed               bool               `json:"has_borrowed"`
	OutOfService              *bool              `json:"out_of_service"`
	IsArchived                bool               `json:"is_archived"`
	ProfilePicture            *string            `json:"profile_picture"`
}

func (q *Queries) ListEmployeeProfile(ctx context.Context, arg ListEmployeeProfileParams) ([]ListEmployeeProfileRow, error) {
	rows, err := q.db.Query(ctx, listEmployeeProfile,
		arg.Limit,
		arg.Offset,
		arg.IncludeArchived,
		arg.IncludeOutOfService,
		arg.Department,
		arg.Position,
		arg.LocationID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeeProfileRow
	for rows.Next() {
		var i ListEmployeeProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Position,
			&i.Department,
			&i.EmployeeNumber,
			&i.EmploymentNumber,
			&i.PrivateEmailAddress,
			&i.Email,
			&i.AuthenticationPhoneNumber,
			&i.PrivatePhoneNumber,
			&i.WorkPhoneNumber,
			&i.DateOfBirth,
			&i.HomeTelephoneNumber,
			&i.Created,
			&i.IsSubcontractor,
			&i.Gender,
			&i.LocationID,
			&i.HasBorrowed,
			&i.OutOfService,
			&i.IsArchived,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
