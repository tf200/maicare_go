// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: employee_profile.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEducationToEmployeeProfile = `-- name: AddEducationToEmployeeProfile :one
INSERT INTO employee_education (
    employee_id,
    institution_name,
    degree,
    field_of_study,
    start_date,
    end_date
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, employee_id, institution_name, degree, field_of_study, start_date, end_date, created_at
`

type AddEducationToEmployeeProfileParams struct {
	EmployeeID      int64       `json:"employee_id"`
	InstitutionName string      `json:"institution_name"`
	Degree          string      `json:"degree"`
	FieldOfStudy    string      `json:"field_of_study"`
	StartDate       pgtype.Date `json:"start_date"`
	EndDate         pgtype.Date `json:"end_date"`
}

func (q *Queries) AddEducationToEmployeeProfile(ctx context.Context, arg AddEducationToEmployeeProfileParams) (EmployeeEducation, error) {
	row := q.db.QueryRow(ctx, addEducationToEmployeeProfile,
		arg.EmployeeID,
		arg.InstitutionName,
		arg.Degree,
		arg.FieldOfStudy,
		arg.StartDate,
		arg.EndDate,
	)
	var i EmployeeEducation
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.InstitutionName,
		&i.Degree,
		&i.FieldOfStudy,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const addEmployeeCertification = `-- name: AddEmployeeCertification :one
INSERT INTO certification (
    employee_id,
    name,
    issued_by,
    date_issued
) VALUES (
    $1, $2, $3, $4
) 
RETURNING id, employee_id, name, issued_by, date_issued, created_at
`

type AddEmployeeCertificationParams struct {
	EmployeeID int64       `json:"employee_id"`
	Name       string      `json:"name"`
	IssuedBy   string      `json:"issued_by"`
	DateIssued pgtype.Date `json:"date_issued"`
}

func (q *Queries) AddEmployeeCertification(ctx context.Context, arg AddEmployeeCertificationParams) (Certification, error) {
	row := q.db.QueryRow(ctx, addEmployeeCertification,
		arg.EmployeeID,
		arg.Name,
		arg.IssuedBy,
		arg.DateIssued,
	)
	var i Certification
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Name,
		&i.IssuedBy,
		&i.DateIssued,
		&i.CreatedAt,
	)
	return i, err
}

const addEmployeeExperience = `-- name: AddEmployeeExperience :one
INSERT INTO employee_experience (
    employee_id,
    job_title,
    company_name,
    start_date,
    end_date,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, employee_id, job_title, company_name, start_date, end_date, description, created_at
`

type AddEmployeeExperienceParams struct {
	EmployeeID  int64       `json:"employee_id"`
	JobTitle    string      `json:"job_title"`
	CompanyName string      `json:"company_name"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Description *string     `json:"description"`
}

func (q *Queries) AddEmployeeExperience(ctx context.Context, arg AddEmployeeExperienceParams) (EmployeeExperience, error) {
	row := q.db.QueryRow(ctx, addEmployeeExperience,
		arg.EmployeeID,
		arg.JobTitle,
		arg.CompanyName,
		arg.StartDate,
		arg.EndDate,
		arg.Description,
	)
	var i EmployeeExperience
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.JobTitle,
		&i.CompanyName,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const countEmployeeProfile = `-- name: CountEmployeeProfile :one
SELECT COUNT(*) 
FROM employee_profile ep
WHERE 
    (CASE 
        WHEN $1::boolean IS NULL THEN true
        WHEN $1::boolean = false THEN NOT ep.is_archived
        ELSE true
    END) AND
    (CASE 
        WHEN $2::boolean IS NULL THEN true
        WHEN $2::boolean = false THEN NOT COALESCE(ep.out_of_service, false)
        ELSE true
    END) AND
    (department = $3 OR $3 IS NULL) AND
    (position = $4 OR $4 IS NULL) AND
    (location_id = $5 OR $5 IS NULL)
`

type CountEmployeeProfileParams struct {
	IncludeArchived     *bool   `json:"include_archived"`
	IncludeOutOfService *bool   `json:"include_out_of_service"`
	Department          *string `json:"department"`
	Position            *string `json:"position"`
	LocationID          *int64  `json:"location_id"`
}

func (q *Queries) CountEmployeeProfile(ctx context.Context, arg CountEmployeeProfileParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployeeProfile,
		arg.IncludeArchived,
		arg.IncludeOutOfService,
		arg.Department,
		arg.Position,
		arg.LocationID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmployeeProfile = `-- name: CreateEmployeeProfile :one
INSERT INTO employee_profile (
    user_id,
    first_name,
    last_name,
    position,
    department,
    employee_number,
    employment_number,
    private_email_address,
    email,
    authentication_phone_number,
    private_phone_number,
    work_phone_number,
    date_of_birth,
    home_telephone_number,
    is_subcontractor,
    gender,
    location_id,
    has_borrowed,
    out_of_service,
    is_archived
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
) RETURNING id, user_id, first_name, last_name, position, department, employee_number, employment_number, private_email_address, email, authentication_phone_number, private_phone_number, work_phone_number, date_of_birth, home_telephone_number, created_at, is_subcontractor, gender, location_id, has_borrowed, out_of_service, is_archived, fixed_contract_hours, variable_contract_hours, contract_start_date, contract_end_date
`

type CreateEmployeeProfileParams struct {
	UserID                    int64       `json:"user_id"`
	FirstName                 string      `json:"first_name"`
	LastName                  string      `json:"last_name"`
	Position                  *string     `json:"position"`
	Department                *string     `json:"department"`
	EmployeeNumber            *string     `json:"employee_number"`
	EmploymentNumber          *string     `json:"employment_number"`
	PrivateEmailAddress       *string     `json:"private_email_address"`
	Email                     string      `json:"email"`
	AuthenticationPhoneNumber *string     `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string     `json:"private_phone_number"`
	WorkPhoneNumber           *string     `json:"work_phone_number"`
	DateOfBirth               pgtype.Date `json:"date_of_birth"`
	HomeTelephoneNumber       *string     `json:"home_telephone_number"`
	IsSubcontractor           *bool       `json:"is_subcontractor"`
	Gender                    *string     `json:"gender"`
	LocationID                *int64      `json:"location_id"`
	HasBorrowed               bool        `json:"has_borrowed"`
	OutOfService              *bool       `json:"out_of_service"`
	IsArchived                bool        `json:"is_archived"`
}

func (q *Queries) CreateEmployeeProfile(ctx context.Context, arg CreateEmployeeProfileParams) (EmployeeProfile, error) {
	row := q.db.QueryRow(ctx, createEmployeeProfile,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.Position,
		arg.Department,
		arg.EmployeeNumber,
		arg.EmploymentNumber,
		arg.PrivateEmailAddress,
		arg.Email,
		arg.AuthenticationPhoneNumber,
		arg.PrivatePhoneNumber,
		arg.WorkPhoneNumber,
		arg.DateOfBirth,
		arg.HomeTelephoneNumber,
		arg.IsSubcontractor,
		arg.Gender,
		arg.LocationID,
		arg.HasBorrowed,
		arg.OutOfService,
		arg.IsArchived,
	)
	var i EmployeeProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Position,
		&i.Department,
		&i.EmployeeNumber,
		&i.EmploymentNumber,
		&i.PrivateEmailAddress,
		&i.Email,
		&i.AuthenticationPhoneNumber,
		&i.PrivatePhoneNumber,
		&i.WorkPhoneNumber,
		&i.DateOfBirth,
		&i.HomeTelephoneNumber,
		&i.CreatedAt,
		&i.IsSubcontractor,
		&i.Gender,
		&i.LocationID,
		&i.HasBorrowed,
		&i.OutOfService,
		&i.IsArchived,
		&i.FixedContractHours,
		&i.VariableContractHours,
		&i.ContractStartDate,
		&i.ContractEndDate,
	)
	return i, err
}

const deleteEmployeeCertification = `-- name: DeleteEmployeeCertification :one
DELETE FROM certification WHERE id = $1 RETURNING id, employee_id, name, issued_by, date_issued, created_at
`

func (q *Queries) DeleteEmployeeCertification(ctx context.Context, id int64) (Certification, error) {
	row := q.db.QueryRow(ctx, deleteEmployeeCertification, id)
	var i Certification
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Name,
		&i.IssuedBy,
		&i.DateIssued,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmployeeEducation = `-- name: DeleteEmployeeEducation :one
DELETE FROM employee_education WHERE id = $1 RETURNING id, employee_id, institution_name, degree, field_of_study, start_date, end_date, created_at
`

func (q *Queries) DeleteEmployeeEducation(ctx context.Context, id int64) (EmployeeEducation, error) {
	row := q.db.QueryRow(ctx, deleteEmployeeEducation, id)
	var i EmployeeEducation
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.InstitutionName,
		&i.Degree,
		&i.FieldOfStudy,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmployeeExperience = `-- name: DeleteEmployeeExperience :one
DELETE FROM employee_experience WHERE id = $1 RETURNING id, employee_id, job_title, company_name, start_date, end_date, description, created_at
`

func (q *Queries) DeleteEmployeeExperience(ctx context.Context, id int64) (EmployeeExperience, error) {
	row := q.db.QueryRow(ctx, deleteEmployeeExperience, id)
	var i EmployeeExperience
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.JobTitle,
		&i.CompanyName,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getEmployeeCounts = `-- name: GetEmployeeCounts :one
SELECT
    COUNT(*) FILTER (WHERE is_subcontractor IS NOT TRUE) AS total_employees,
    COUNT(*) FILTER (WHERE is_subcontractor = TRUE) AS total_subcontractors,
    COUNT(*) FILTER (WHERE is_archived = TRUE) AS total_archived,
    COUNT(*) FILTER (WHERE out_of_service = TRUE) AS total_out_of_service
FROM
    employee_profile
`

type GetEmployeeCountsRow struct {
	TotalEmployees      int64 `json:"total_employees"`
	TotalSubcontractors int64 `json:"total_subcontractors"`
	TotalArchived       int64 `json:"total_archived"`
	TotalOutOfService   int64 `json:"total_out_of_service"`
}

func (q *Queries) GetEmployeeCounts(ctx context.Context) (GetEmployeeCountsRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeCounts)
	var i GetEmployeeCountsRow
	err := row.Scan(
		&i.TotalEmployees,
		&i.TotalSubcontractors,
		&i.TotalArchived,
		&i.TotalOutOfService,
	)
	return i, err
}

const getEmployeeIDByUserID = `-- name: GetEmployeeIDByUserID :one
SELECT 
    ep.id AS employee_id
FROM employee_profile ep
JOIN custom_user cu ON ep.user_id = cu.id
WHERE cu.id = $1
`

func (q *Queries) GetEmployeeIDByUserID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getEmployeeIDByUserID, id)
	var employee_id int64
	err := row.Scan(&employee_id)
	return employee_id, err
}

const getEmployeeProfileByID = `-- name: GetEmployeeProfileByID :one
SELECT 
    ep.id, ep.user_id, ep.first_name, ep.last_name, ep.position, ep.department, ep.employee_number, ep.employment_number, ep.private_email_address, ep.email, ep.authentication_phone_number, ep.private_phone_number, ep.work_phone_number, ep.date_of_birth, ep.home_telephone_number, ep.created_at, ep.is_subcontractor, ep.gender, ep.location_id, ep.has_borrowed, ep.out_of_service, ep.is_archived, ep.fixed_contract_hours, ep.variable_contract_hours, ep.contract_start_date, ep.contract_end_date,
    cu.profile_picture as profile_picture,
    cu.role_id
FROM employee_profile ep
JOIN custom_user cu ON ep.user_id = cu.id
WHERE ep.id = $1
`

type GetEmployeeProfileByIDRow struct {
	ID                        int64              `json:"id"`
	UserID                    int64              `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	Position                  *string            `json:"position"`
	Department                *string            `json:"department"`
	EmployeeNumber            *string            `json:"employee_number"`
	EmploymentNumber          *string            `json:"employment_number"`
	PrivateEmailAddress       *string            `json:"private_email_address"`
	Email                     string             `json:"email"`
	AuthenticationPhoneNumber *string            `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string            `json:"private_phone_number"`
	WorkPhoneNumber           *string            `json:"work_phone_number"`
	DateOfBirth               pgtype.Date        `json:"date_of_birth"`
	HomeTelephoneNumber       *string            `json:"home_telephone_number"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	IsSubcontractor           *bool              `json:"is_subcontractor"`
	Gender                    *string            `json:"gender"`
	LocationID                *int64             `json:"location_id"`
	HasBorrowed               bool               `json:"has_borrowed"`
	OutOfService              *bool              `json:"out_of_service"`
	IsArchived                bool               `json:"is_archived"`
	FixedContractHours        *float64           `json:"fixed_contract_hours"`
	VariableContractHours     *float64           `json:"variable_contract_hours"`
	ContractStartDate         pgtype.Date        `json:"contract_start_date"`
	ContractEndDate           pgtype.Date        `json:"contract_end_date"`
	ProfilePicture            *string            `json:"profile_picture"`
	RoleID                    int32              `json:"role_id"`
}

func (q *Queries) GetEmployeeProfileByID(ctx context.Context, id int64) (GetEmployeeProfileByIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeProfileByID, id)
	var i GetEmployeeProfileByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Position,
		&i.Department,
		&i.EmployeeNumber,
		&i.EmploymentNumber,
		&i.PrivateEmailAddress,
		&i.Email,
		&i.AuthenticationPhoneNumber,
		&i.PrivatePhoneNumber,
		&i.WorkPhoneNumber,
		&i.DateOfBirth,
		&i.HomeTelephoneNumber,
		&i.CreatedAt,
		&i.IsSubcontractor,
		&i.Gender,
		&i.LocationID,
		&i.HasBorrowed,
		&i.OutOfService,
		&i.IsArchived,
		&i.FixedContractHours,
		&i.VariableContractHours,
		&i.ContractStartDate,
		&i.ContractEndDate,
		&i.ProfilePicture,
		&i.RoleID,
	)
	return i, err
}

const getEmployeeProfileByUserID = `-- name: GetEmployeeProfileByUserID :one
SELECT 
    cu.id as user_id,
    cu.email as email,
    ep.id as employee_id,
    ep.first_name,
    ep.last_name,
    cu.role_id,
    json_agg(json_build_object(
        'id', p.id,
        'name', p.name,
        'resource', p.resource,
        'method', p.method
    )) AS permissions
FROM custom_user cu
JOIN employee_profile ep ON ep.user_id = cu.id
JOIN role_permissions rp ON rp.role_id = cu.role_id
JOIN permissions p ON p.id = rp.permission_id
WHERE cu.id = $1
GROUP BY cu.id, cu.email, ep.id, ep.first_name, ep.last_name, cu.role_id
`

type GetEmployeeProfileByUserIDRow struct {
	UserID      int64  `json:"user_id"`
	Email       string `json:"email"`
	EmployeeID  int64  `json:"employee_id"`
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	RoleID      int32  `json:"role_id"`
	Permissions []byte `json:"permissions"`
}

func (q *Queries) GetEmployeeProfileByUserID(ctx context.Context, id int64) (GetEmployeeProfileByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeProfileByUserID, id)
	var i GetEmployeeProfileByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.EmployeeID,
		&i.FirstName,
		&i.LastName,
		&i.RoleID,
		&i.Permissions,
	)
	return i, err
}

const listEducations = `-- name: ListEducations :many
SELECT id, employee_id, institution_name, degree, field_of_study, start_date, end_date, created_at FROM employee_education WHERE employee_id = $1
`

func (q *Queries) ListEducations(ctx context.Context, employeeID int64) ([]EmployeeEducation, error) {
	rows, err := q.db.Query(ctx, listEducations, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeeEducation
	for rows.Next() {
		var i EmployeeEducation
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.InstitutionName,
			&i.Degree,
			&i.FieldOfStudy,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeeCertifications = `-- name: ListEmployeeCertifications :many
SELECT id, employee_id, name, issued_by, date_issued, created_at FROM certification WHERE employee_id = $1
`

func (q *Queries) ListEmployeeCertifications(ctx context.Context, employeeID int64) ([]Certification, error) {
	rows, err := q.db.Query(ctx, listEmployeeCertifications, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certification
	for rows.Next() {
		var i Certification
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.Name,
			&i.IssuedBy,
			&i.DateIssued,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeeExperience = `-- name: ListEmployeeExperience :many
SELECT id, employee_id, job_title, company_name, start_date, end_date, description, created_at FROM employee_experience WHERE employee_id = $1
`

func (q *Queries) ListEmployeeExperience(ctx context.Context, employeeID int64) ([]EmployeeExperience, error) {
	rows, err := q.db.Query(ctx, listEmployeeExperience, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeeExperience
	for rows.Next() {
		var i EmployeeExperience
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.JobTitle,
			&i.CompanyName,
			&i.StartDate,
			&i.EndDate,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeeProfile = `-- name: ListEmployeeProfile :many
SELECT 
    ep.id, ep.user_id, ep.first_name, ep.last_name, ep.position, ep.department, ep.employee_number, ep.employment_number, ep.private_email_address, ep.email, ep.authentication_phone_number, ep.private_phone_number, ep.work_phone_number, ep.date_of_birth, ep.home_telephone_number, ep.created_at, ep.is_subcontractor, ep.gender, ep.location_id, ep.has_borrowed, ep.out_of_service, ep.is_archived, ep.fixed_contract_hours, ep.variable_contract_hours, ep.contract_start_date, ep.contract_end_date,
    u.profile_picture as profile_picture
FROM employee_profile ep
JOIN custom_user u ON ep.user_id = u.id
WHERE 
    (CASE 
        WHEN $3::boolean IS NULL THEN true
        WHEN $3::boolean = false THEN NOT ep.is_archived
        ELSE true
    END) AND
    (CASE 
        WHEN $4::boolean IS NULL THEN true
        WHEN $4::boolean = false THEN NOT COALESCE(ep.out_of_service, false)
        ELSE true
    END) AND
    (ep.department = $5 OR $5 IS NULL) AND
    (ep.position = $6 OR $6 IS NULL) AND
    (ep.location_id = $7 OR $7 IS NULL) AND
    ($8::TEXT IS NULL OR 
        ep.first_name ILIKE '%' || $8 || '%' OR 
        ep.last_name ILIKE '%' || $8 || '%')
ORDER BY ep.created_at DESC
LIMIT $1 OFFSET $2
`

type ListEmployeeProfileParams struct {
	Limit               int32   `json:"limit"`
	Offset              int32   `json:"offset"`
	IncludeArchived     *bool   `json:"include_archived"`
	IncludeOutOfService *bool   `json:"include_out_of_service"`
	Department          *string `json:"department"`
	Position            *string `json:"position"`
	LocationID          *int64  `json:"location_id"`
	Search              *string `json:"search"`
}

type ListEmployeeProfileRow struct {
	ID                        int64              `json:"id"`
	UserID                    int64              `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	Position                  *string            `json:"position"`
	Department                *string            `json:"department"`
	EmployeeNumber            *string            `json:"employee_number"`
	EmploymentNumber          *string            `json:"employment_number"`
	PrivateEmailAddress       *string            `json:"private_email_address"`
	Email                     string             `json:"email"`
	AuthenticationPhoneNumber *string            `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string            `json:"private_phone_number"`
	WorkPhoneNumber           *string            `json:"work_phone_number"`
	DateOfBirth               pgtype.Date        `json:"date_of_birth"`
	HomeTelephoneNumber       *string            `json:"home_telephone_number"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	IsSubcontractor           *bool              `json:"is_subcontractor"`
	Gender                    *string            `json:"gender"`
	LocationID                *int64             `json:"location_id"`
	HasBorrowed               bool               `json:"has_borrowed"`
	OutOfService              *bool              `json:"out_of_service"`
	IsArchived                bool               `json:"is_archived"`
	FixedContractHours        *float64           `json:"fixed_contract_hours"`
	VariableContractHours     *float64           `json:"variable_contract_hours"`
	ContractStartDate         pgtype.Date        `json:"contract_start_date"`
	ContractEndDate           pgtype.Date        `json:"contract_end_date"`
	ProfilePicture            *string            `json:"profile_picture"`
}

func (q *Queries) ListEmployeeProfile(ctx context.Context, arg ListEmployeeProfileParams) ([]ListEmployeeProfileRow, error) {
	rows, err := q.db.Query(ctx, listEmployeeProfile,
		arg.Limit,
		arg.Offset,
		arg.IncludeArchived,
		arg.IncludeOutOfService,
		arg.Department,
		arg.Position,
		arg.LocationID,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeeProfileRow
	for rows.Next() {
		var i ListEmployeeProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Position,
			&i.Department,
			&i.EmployeeNumber,
			&i.EmploymentNumber,
			&i.PrivateEmailAddress,
			&i.Email,
			&i.AuthenticationPhoneNumber,
			&i.PrivatePhoneNumber,
			&i.WorkPhoneNumber,
			&i.DateOfBirth,
			&i.HomeTelephoneNumber,
			&i.CreatedAt,
			&i.IsSubcontractor,
			&i.Gender,
			&i.LocationID,
			&i.HasBorrowed,
			&i.OutOfService,
			&i.IsArchived,
			&i.FixedContractHours,
			&i.VariableContractHours,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEmployeesByNameOrEmail = `-- name: SearchEmployeesByNameOrEmail :many
SELECT
    id,
    first_name,
    last_name,
    email
FROM employee_profile
WHERE 
    first_name ILIKE '%' || $1 || '%' OR
    last_name ILIKE '%' || $1 || '%' OR
    email ILIKE '%' || $1 || '%'
LIMIT 10
`

type SearchEmployeesByNameOrEmailRow struct {
	ID        int64  `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) SearchEmployeesByNameOrEmail(ctx context.Context, search *string) ([]SearchEmployeesByNameOrEmailRow, error) {
	rows, err := q.db.Query(ctx, searchEmployeesByNameOrEmail, search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchEmployeesByNameOrEmailRow
	for rows.Next() {
		var i SearchEmployeesByNameOrEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEmployeeProfilePicture = `-- name: SetEmployeeProfilePicture :one
UPDATE custom_user
SET profile_picture = $2
WHERE id = (
    SELECT user_id 
    FROM employee_profile
    WHERE employee_profile.id = $1
)
RETURNING id, password, last_login, email, role_id, is_active, date_joined, profile_picture, two_factor_enabled, two_factor_secret, two_factor_secret_temp, recovery_codes
`

type SetEmployeeProfilePictureParams struct {
	ID             int64   `json:"id"`
	ProfilePicture *string `json:"profile_picture"`
}

func (q *Queries) SetEmployeeProfilePicture(ctx context.Context, arg SetEmployeeProfilePictureParams) (CustomUser, error) {
	row := q.db.QueryRow(ctx, setEmployeeProfilePicture, arg.ID, arg.ProfilePicture)
	var i CustomUser
	err := row.Scan(
		&i.ID,
		&i.Password,
		&i.LastLogin,
		&i.Email,
		&i.RoleID,
		&i.IsActive,
		&i.DateJoined,
		&i.ProfilePicture,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretTemp,
		&i.RecoveryCodes,
	)
	return i, err
}

const updateEmployeeCertification = `-- name: UpdateEmployeeCertification :one
UPDATE certification
SET
    name = COALESCE($2, name),
    issued_by = COALESCE($3, issued_by),
    date_issued = COALESCE($4, date_issued)
WHERE id = $1
RETURNING id, employee_id, name, issued_by, date_issued, created_at
`

type UpdateEmployeeCertificationParams struct {
	ID         int64       `json:"id"`
	Name       *string     `json:"name"`
	IssuedBy   *string     `json:"issued_by"`
	DateIssued pgtype.Date `json:"date_issued"`
}

func (q *Queries) UpdateEmployeeCertification(ctx context.Context, arg UpdateEmployeeCertificationParams) (Certification, error) {
	row := q.db.QueryRow(ctx, updateEmployeeCertification,
		arg.ID,
		arg.Name,
		arg.IssuedBy,
		arg.DateIssued,
	)
	var i Certification
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.Name,
		&i.IssuedBy,
		&i.DateIssued,
		&i.CreatedAt,
	)
	return i, err
}

const updateEmployeeEducation = `-- name: UpdateEmployeeEducation :one
UPDATE employee_education
SET
    institution_name = COALESCE($2, institution_name),
    degree = COALESCE($3, degree),
    field_of_study = COALESCE($4, field_of_study),
    start_date = COALESCE($5, start_date),
    end_date = COALESCE($6, end_date)
WHERE id = $1
RETURNING id, employee_id, institution_name, degree, field_of_study, start_date, end_date, created_at
`

type UpdateEmployeeEducationParams struct {
	ID              int64       `json:"id"`
	InstitutionName *string     `json:"institution_name"`
	Degree          *string     `json:"degree"`
	FieldOfStudy    *string     `json:"field_of_study"`
	StartDate       pgtype.Date `json:"start_date"`
	EndDate         pgtype.Date `json:"end_date"`
}

func (q *Queries) UpdateEmployeeEducation(ctx context.Context, arg UpdateEmployeeEducationParams) (EmployeeEducation, error) {
	row := q.db.QueryRow(ctx, updateEmployeeEducation,
		arg.ID,
		arg.InstitutionName,
		arg.Degree,
		arg.FieldOfStudy,
		arg.StartDate,
		arg.EndDate,
	)
	var i EmployeeEducation
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.InstitutionName,
		&i.Degree,
		&i.FieldOfStudy,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const updateEmployeeExperience = `-- name: UpdateEmployeeExperience :one
UPDATE employee_experience
SET
    job_title = COALESCE($2, job_title),
    company_name = COALESCE($3, company_name),
    start_date = COALESCE($4, start_date),
    end_date = COALESCE($5, end_date),
    description = COALESCE($6, description)
WHERE id = $1
RETURNING id, employee_id, job_title, company_name, start_date, end_date, description, created_at
`

type UpdateEmployeeExperienceParams struct {
	ID          int64       `json:"id"`
	JobTitle    *string     `json:"job_title"`
	CompanyName *string     `json:"company_name"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Description *string     `json:"description"`
}

func (q *Queries) UpdateEmployeeExperience(ctx context.Context, arg UpdateEmployeeExperienceParams) (EmployeeExperience, error) {
	row := q.db.QueryRow(ctx, updateEmployeeExperience,
		arg.ID,
		arg.JobTitle,
		arg.CompanyName,
		arg.StartDate,
		arg.EndDate,
		arg.Description,
	)
	var i EmployeeExperience
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.JobTitle,
		&i.CompanyName,
		&i.StartDate,
		&i.EndDate,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const updateEmployeeProfile = `-- name: UpdateEmployeeProfile :one
UPDATE employee_profile
SET
    first_name = COALESCE($1, first_name),
    last_name = COALESCE($2, last_name),
    position = COALESCE($3, position),
    department = COALESCE($4, department),
    employee_number = COALESCE($5, employee_number),
    employment_number = COALESCE($6, employment_number),
    private_email_address = COALESCE($7, private_email_address),
    email = COALESCE($8, email),
    authentication_phone_number = COALESCE($9, authentication_phone_number),
    private_phone_number = COALESCE($10, private_phone_number),
    work_phone_number = COALESCE($11, work_phone_number),
    date_of_birth = COALESCE($12, date_of_birth),
    home_telephone_number = COALESCE($13, home_telephone_number),
    is_subcontractor = COALESCE($14, is_subcontractor),
    gender = COALESCE($15, gender),
    location_id = COALESCE($16, location_id),
    has_borrowed = COALESCE($17, has_borrowed),
    out_of_service = COALESCE($18, out_of_service),
    is_archived = COALESCE($19, is_archived)
WHERE id = $20
RETURNING id, user_id, first_name, last_name, position, department, employee_number, employment_number, private_email_address, email, authentication_phone_number, private_phone_number, work_phone_number, date_of_birth, home_telephone_number, created_at, is_subcontractor, gender, location_id, has_borrowed, out_of_service, is_archived, fixed_contract_hours, variable_contract_hours, contract_start_date, contract_end_date
`

type UpdateEmployeeProfileParams struct {
	FirstName                 *string     `json:"first_name"`
	LastName                  *string     `json:"last_name"`
	Position                  *string     `json:"position"`
	Department                *string     `json:"department"`
	EmployeeNumber            *string     `json:"employee_number"`
	EmploymentNumber          *string     `json:"employment_number"`
	PrivateEmailAddress       *string     `json:"private_email_address"`
	Email                     *string     `json:"email"`
	AuthenticationPhoneNumber *string     `json:"authentication_phone_number"`
	PrivatePhoneNumber        *string     `json:"private_phone_number"`
	WorkPhoneNumber           *string     `json:"work_phone_number"`
	DateOfBirth               pgtype.Date `json:"date_of_birth"`
	HomeTelephoneNumber       *string     `json:"home_telephone_number"`
	IsSubcontractor           *bool       `json:"is_subcontractor"`
	Gender                    *string     `json:"gender"`
	LocationID                *int64      `json:"location_id"`
	HasBorrowed               *bool       `json:"has_borrowed"`
	OutOfService              *bool       `json:"out_of_service"`
	IsArchived                *bool       `json:"is_archived"`
	ID                        int64       `json:"id"`
}

func (q *Queries) UpdateEmployeeProfile(ctx context.Context, arg UpdateEmployeeProfileParams) (EmployeeProfile, error) {
	row := q.db.QueryRow(ctx, updateEmployeeProfile,
		arg.FirstName,
		arg.LastName,
		arg.Position,
		arg.Department,
		arg.EmployeeNumber,
		arg.EmploymentNumber,
		arg.PrivateEmailAddress,
		arg.Email,
		arg.AuthenticationPhoneNumber,
		arg.PrivatePhoneNumber,
		arg.WorkPhoneNumber,
		arg.DateOfBirth,
		arg.HomeTelephoneNumber,
		arg.IsSubcontractor,
		arg.Gender,
		arg.LocationID,
		arg.HasBorrowed,
		arg.OutOfService,
		arg.IsArchived,
		arg.ID,
	)
	var i EmployeeProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Position,
		&i.Department,
		&i.EmployeeNumber,
		&i.EmploymentNumber,
		&i.PrivateEmailAddress,
		&i.Email,
		&i.AuthenticationPhoneNumber,
		&i.PrivatePhoneNumber,
		&i.WorkPhoneNumber,
		&i.DateOfBirth,
		&i.HomeTelephoneNumber,
		&i.CreatedAt,
		&i.IsSubcontractor,
		&i.Gender,
		&i.LocationID,
		&i.HasBorrowed,
		&i.OutOfService,
		&i.IsArchived,
		&i.FixedContractHours,
		&i.VariableContractHours,
		&i.ContractStartDate,
		&i.ContractEndDate,
	)
	return i, err
}
