// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ECR.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clientsOnWaitlist = `-- name: ClientsOnWaitlist :one
SELECT COUNT(id) AS total_clients_on_waitlist
FROM client_details
WHERE status = 'On Waitlist'
`

func (q *Queries) ClientsOnWaitlist(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, clientsOnWaitlist)
	var total_clients_on_waitlist int64
	err := row.Scan(&total_clients_on_waitlist)
	return total_clients_on_waitlist, err
}

const contractEndCount = `-- name: ContractEndCount :one
SELECT COUNT(*) as contract_end_count
FROM client_details cd
JOIN contract c ON cd.id = c.client_id
WHERE cd.status = 'In Care' 
  AND c.status = 'approved'
  AND c.end_date <= CURRENT_DATE + INTERVAL '3 months'
  -- Exclude clients who are already included in the scheduled status changes
  AND NOT EXISTS (
      SELECT 1 
      FROM scheduled_status_changes ssc 
      WHERE cd.id = ssc.client_id 
        AND ssc.new_status = 'Out Of Care'
        AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
  )
`

func (q *Queries) ContractEndCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, contractEndCount)
	var contract_end_count int64
	err := row.Scan(&contract_end_count)
	return contract_end_count, err
}

const dischargeOverview = `-- name: DischargeOverview :many
WITH client_discharges AS (
    -- Get clients with scheduled status change to "Out Of Care"
    SELECT 
        cd.id, 
        cd.first_name,
        cd.last_name,
        cd.status AS current_status, 
        ssc.new_status AS scheduled_status, 
        ssc.reason AS status_change_reason, 
        ssc.scheduled_date AS status_change_date, 
        c.end_date::date AS contract_end_date, 
        c.status AS contract_status, 
        c.departure_reason, 
        c.departure_report AS follow_up_plan,
        'scheduled_status' AS discharge_type
    FROM client_details cd
    JOIN scheduled_status_changes ssc ON cd.id = ssc.client_id
    LEFT JOIN contract c ON cd.id = c.client_id AND c.status = 'approved'
    WHERE cd.status = 'In Care' 
      AND ssc.new_status = 'Out Of Care'
      AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
    
    UNION ALL
    
    -- Get clients with contracts ending in the next 3 months
    SELECT 
        cd.id, 
        cd.first_name,
        cd.last_name,
        cd.status AS current_status, 
        NULL AS scheduled_status, 
        NULL AS status_change_reason, 
        NULL AS status_change_date, 
        c.end_date::date AS contract_end_date, 
        c.status AS contract_status, 
        c.departure_reason, 
        c.departure_report AS follow_up_plan,
        'contract_end' AS discharge_type
    FROM client_details cd
    JOIN contract c ON cd.id = c.client_id
    WHERE cd.status = 'In Care' 
      AND c.status = 'approved'
      AND c.end_date <= CURRENT_DATE + INTERVAL '3 months'
      -- Exclude clients who are already included in the scheduled status changes
      AND NOT EXISTS (
          SELECT 1 
          FROM scheduled_status_changes ssc 
          WHERE cd.id = ssc.client_id 
            AND ssc.new_status = 'Out Of Care'
            AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
      )
)
SELECT id, first_name, last_name, current_status, scheduled_status, status_change_reason, status_change_date, contract_end_date, contract_status, departure_reason, follow_up_plan, discharge_type FROM client_discharges 
WHERE 
    -- Filter based on parameter filter_type:
    -- 'all' or NULL = Show all (default)
    -- 'status_change' = Show only status changes within 3 months
    -- 'contract' = Show only contract endings within 3 months
    -- 'urgent' = Show both status changes and contract endings within 1 month
    ($3::text IS NULL OR $3::text = 'all') OR 
    ($3::text = 'status_change' AND discharge_type = 'scheduled_status' AND status_change_date <= CURRENT_DATE + INTERVAL '3 months') OR
    ($3::text = 'contract' AND discharge_type = 'contract_end' AND contract_end_date <= CURRENT_DATE + INTERVAL '3 months') OR
    ($3::text = 'urgent' AND (
        (discharge_type = 'scheduled_status' AND status_change_date <= CURRENT_DATE + INTERVAL '1 month') OR
        (discharge_type = 'contract_end' AND contract_end_date <= CURRENT_DATE + INTERVAL '1 month')
    ))
ORDER BY 
    CASE WHEN discharge_type = 'scheduled_status' THEN status_change_date ELSE contract_end_date END ASC
LIMIT $1 OFFSET $2
`

type DischargeOverviewParams struct {
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
	FilterType string `json:"filter_type"`
}

type DischargeOverviewRow struct {
	ID                 int64       `json:"id"`
	FirstName          string      `json:"first_name"`
	LastName           string      `json:"last_name"`
	CurrentStatus      *string     `json:"current_status"`
	ScheduledStatus    string      `json:"scheduled_status"`
	StatusChangeReason *string     `json:"status_change_reason"`
	StatusChangeDate   pgtype.Date `json:"status_change_date"`
	ContractEndDate    pgtype.Date `json:"contract_end_date"`
	ContractStatus     *string     `json:"contract_status"`
	DepartureReason    *string     `json:"departure_reason"`
	FollowUpPlan       *string     `json:"follow_up_plan"`
	DischargeType      string      `json:"discharge_type"`
}

func (q *Queries) DischargeOverview(ctx context.Context, arg DischargeOverviewParams) ([]DischargeOverviewRow, error) {
	rows, err := q.db.Query(ctx, dischargeOverview, arg.Limit, arg.Offset, arg.FilterType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DischargeOverviewRow
	for rows.Next() {
		var i DischargeOverviewRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.CurrentStatus,
			&i.ScheduledStatus,
			&i.StatusChangeReason,
			&i.StatusChangeDate,
			&i.ContractEndDate,
			&i.ContractStatus,
			&i.DepartureReason,
			&i.FollowUpPlan,
			&i.DischargeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesByContractEndDate = `-- name: ListEmployeesByContractEndDate :many
SELECT 
    id,
    user_id,
    first_name,
    last_name,
    position,
    department,
    employee_number,
    employment_number,
    email,
    contract_start_date,
    contract_end_date,
    contract_type
FROM employee_profile 
WHERE contract_end_date IS NOT NULL
  AND is_archived = FALSE
ORDER BY contract_end_date ASC
LIMIT 10
`

type ListEmployeesByContractEndDateRow struct {
	ID                int64       `json:"id"`
	UserID            int64       `json:"user_id"`
	FirstName         string      `json:"first_name"`
	LastName          string      `json:"last_name"`
	Position          *string     `json:"position"`
	Department        *string     `json:"department"`
	EmployeeNumber    *string     `json:"employee_number"`
	EmploymentNumber  *string     `json:"employment_number"`
	Email             string      `json:"email"`
	ContractStartDate pgtype.Date `json:"contract_start_date"`
	ContractEndDate   pgtype.Date `json:"contract_end_date"`
	ContractType      *string     `json:"contract_type"`
}

func (q *Queries) ListEmployeesByContractEndDate(ctx context.Context) ([]ListEmployeesByContractEndDateRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesByContractEndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeesByContractEndDateRow
	for rows.Next() {
		var i ListEmployeesByContractEndDateRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Position,
			&i.Department,
			&i.EmployeeNumber,
			&i.EmploymentNumber,
			&i.Email,
			&i.ContractStartDate,
			&i.ContractEndDate,
			&i.ContractType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recentIncidents = `-- name: RecentIncidents :one
SELECT COUNT(id) AS total_recent_incidents
FROM incident
WHERE created_at >= CURRENT_DATE - INTERVAL '48 hours'
`

func (q *Queries) RecentIncidents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, recentIncidents)
	var total_recent_incidents int64
	err := row.Scan(&total_recent_incidents)
	return total_recent_incidents, err
}

const statusChangeCount = `-- name: StatusChangeCount :one
SELECT COUNT(*) as status_changes_count
FROM client_details cd
JOIN scheduled_status_changes ssc ON cd.id = ssc.client_id
WHERE cd.status = 'In Care' 
  AND ssc.new_status = 'Out Of Care'
  AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
`

func (q *Queries) StatusChangeCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, statusChangeCount)
	var status_changes_count int64
	err := row.Scan(&status_changes_count)
	return status_changes_count, err
}

const totalActiveClients = `-- name: TotalActiveClients :one
SELECT COUNT(id) AS total_active_clients 
FROM client_details
WHERE status = 'In Care'
`

func (q *Queries) TotalActiveClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalActiveClients)
	var total_active_clients int64
	err := row.Scan(&total_active_clients)
	return total_active_clients, err
}

const totalDischargeCount = `-- name: TotalDischargeCount :one
WITH client_discharges AS (
    -- Get clients with scheduled status change to "Out Of Care"
    SELECT cd.id, 'scheduled_status' AS discharge_type
    FROM client_details cd
    JOIN scheduled_status_changes ssc ON cd.id = ssc.client_id
    WHERE cd.status = 'In Care' 
      AND ssc.new_status = 'Out Of Care'
      AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
    
    UNION ALL
    
    -- Get clients with contracts ending in the next 3 months
    SELECT cd.id, 'contract_end' AS discharge_type
    FROM client_details cd
    JOIN contract c ON cd.id = c.client_id
    WHERE cd.status = 'In Care' 
      AND c.status = 'approved'
      AND c.end_date <= CURRENT_DATE + INTERVAL '3 months'
      -- Exclude clients who are already included in the scheduled status changes
      AND NOT EXISTS (
          SELECT 1 
          FROM scheduled_status_changes ssc 
          WHERE cd.id = ssc.client_id 
            AND ssc.new_status = 'Out Of Care'
            AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '3 months'
      )
)
SELECT COUNT(*) as total_discharges
FROM client_discharges
`

func (q *Queries) TotalDischargeCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, totalDischargeCount)
	var total_discharges int64
	err := row.Scan(&total_discharges)
	return total_discharges, err
}

const urgentCasesCount = `-- name: UrgentCasesCount :one
WITH client_discharges AS (
    -- Get clients with scheduled status change to "Out Of Care"
    SELECT 
        cd.id,
        ssc.scheduled_date AS relevant_date
    FROM client_details cd
    JOIN scheduled_status_changes ssc ON cd.id = ssc.client_id
    WHERE cd.status = 'In Care' 
      AND ssc.new_status = 'Out Of Care'
      AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '30 days'
    
    UNION ALL
    
    -- Get clients with contracts ending in the next 30 days
    SELECT 
        cd.id,
        c.end_date AS relevant_date
    FROM client_details cd
    JOIN contract c ON cd.id = c.client_id
    WHERE cd.status = 'In Care' 
      AND c.status = 'approved'
      AND c.end_date <= CURRENT_DATE + INTERVAL '30 days'
      -- Exclude clients who are already included in the scheduled status changes
      AND NOT EXISTS (
          SELECT 1 
          FROM scheduled_status_changes ssc 
          WHERE cd.id = ssc.client_id 
            AND ssc.new_status = 'Out Of Care'
            AND ssc.scheduled_date <= CURRENT_DATE + INTERVAL '30 days'
      )
)
SELECT COUNT(*) as urgent_count
FROM client_discharges
`

func (q *Queries) UrgentCasesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, urgentCasesCount)
	var urgent_count int64
	err := row.Scan(&urgent_count)
	return urgent_count, err
}
