// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sender.sql

package db

import (
	"context"
)

const countSenders = `-- name: CountSenders :one
SELECT COUNT(*) 
FROM sender
WHERE (
  CASE 
    WHEN $1::boolean IS NULL THEN NOT is_archived
    WHEN $1::boolean THEN true 
    ELSE NOT is_archived
  END
)
`

func (q *Queries) CountSenders(ctx context.Context, includeArchived *bool) (int64, error) {
	row := q.db.QueryRow(ctx, countSenders, includeArchived)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSender = `-- name: CreateSender :one
INSERT INTO sender (
    types,
    name,
    address,
    postal_code,
    place,
    land,
    kvknumber,
    btwnumber,
    phone_number,
    client_number,
    email_address,
    contacts
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, types, name, address, postal_code, place, land, kvknumber, btwnumber, phone_number, client_number, email_address, contacts, invoice_template, is_archived, created_at, updated_at
`

type CreateSenderParams struct {
	Types        string  `json:"types"`
	Name         string  `json:"name"`
	Address      *string `json:"address"`
	PostalCode   *string `json:"postal_code"`
	Place        *string `json:"place"`
	Land         *string `json:"land"`
	Kvknumber    *string `json:"kvknumber"`
	Btwnumber    *string `json:"btwnumber"`
	PhoneNumber  *string `json:"phone_number"`
	ClientNumber *string `json:"client_number"`
	EmailAddress *string `json:"email_address"`
	Contacts     []byte  `json:"contacts"`
}

func (q *Queries) CreateSender(ctx context.Context, arg CreateSenderParams) (Sender, error) {
	row := q.db.QueryRow(ctx, createSender,
		arg.Types,
		arg.Name,
		arg.Address,
		arg.PostalCode,
		arg.Place,
		arg.Land,
		arg.Kvknumber,
		arg.Btwnumber,
		arg.PhoneNumber,
		arg.ClientNumber,
		arg.EmailAddress,
		arg.Contacts,
	)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.Types,
		&i.Name,
		&i.Address,
		&i.PostalCode,
		&i.Place,
		&i.Land,
		&i.Kvknumber,
		&i.Btwnumber,
		&i.PhoneNumber,
		&i.ClientNumber,
		&i.EmailAddress,
		&i.Contacts,
		&i.InvoiceTemplate,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSenderInvoiceTemplate = `-- name: CreateSenderInvoiceTemplate :one
UPDATE sender
SET
    invoice_template = COALESCE($1, invoice_template)
WHERE id = $2
RETURNING invoice_template
`

type CreateSenderInvoiceTemplateParams struct {
	InvoiceTemplate []int64 `json:"invoice_template"`
	ID              int64   `json:"id"`
}

func (q *Queries) CreateSenderInvoiceTemplate(ctx context.Context, arg CreateSenderInvoiceTemplateParams) ([]int64, error) {
	row := q.db.QueryRow(ctx, createSenderInvoiceTemplate, arg.InvoiceTemplate, arg.ID)
	var invoice_template []int64
	err := row.Scan(&invoice_template)
	return invoice_template, err
}

const deleteSender = `-- name: DeleteSender :exec
UPDATE sender
SET
    is_archived = true,
    updated_at = NOW()
WHERE 
    id = $1
`

func (q *Queries) DeleteSender(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSender, id)
	return err
}

const getSenderById = `-- name: GetSenderById :one
SELECT id, types, name, address, postal_code, place, land, kvknumber, btwnumber, phone_number, client_number, email_address, contacts, invoice_template, is_archived, created_at, updated_at FROM sender
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSenderById(ctx context.Context, id int64) (Sender, error) {
	row := q.db.QueryRow(ctx, getSenderById, id)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.Types,
		&i.Name,
		&i.Address,
		&i.PostalCode,
		&i.Place,
		&i.Land,
		&i.Kvknumber,
		&i.Btwnumber,
		&i.PhoneNumber,
		&i.ClientNumber,
		&i.EmailAddress,
		&i.Contacts,
		&i.InvoiceTemplate,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSenderInvoiceTemplate = `-- name: GetSenderInvoiceTemplate :one
SELECT invoice_template
FROM sender
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSenderInvoiceTemplate(ctx context.Context, id int64) ([]int64, error) {
	row := q.db.QueryRow(ctx, getSenderInvoiceTemplate, id)
	var invoice_template []int64
	err := row.Scan(&invoice_template)
	return invoice_template, err
}

const listSenders = `-- name: ListSenders :many
SELECT id, types, name, address, postal_code, place, land, kvknumber, btwnumber, phone_number, client_number, email_address, contacts, invoice_template, is_archived, created_at, updated_at FROM sender
WHERE 
   (CASE WHEN $3::boolean THEN true ELSE NOT is_archived END)
   AND ($4::TEXT IS NULL OR name ILIKE '%' || $4 || '%')
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListSendersParams struct {
	Limit           int32   `json:"limit"`
	Offset          int32   `json:"offset"`
	IncludeArchived *bool   `json:"include_archived"`
	Search          *string `json:"search"`
}

func (q *Queries) ListSenders(ctx context.Context, arg ListSendersParams) ([]Sender, error) {
	rows, err := q.db.Query(ctx, listSenders,
		arg.Limit,
		arg.Offset,
		arg.IncludeArchived,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sender
	for rows.Next() {
		var i Sender
		if err := rows.Scan(
			&i.ID,
			&i.Types,
			&i.Name,
			&i.Address,
			&i.PostalCode,
			&i.Place,
			&i.Land,
			&i.Kvknumber,
			&i.Btwnumber,
			&i.PhoneNumber,
			&i.ClientNumber,
			&i.EmailAddress,
			&i.Contacts,
			&i.InvoiceTemplate,
			&i.IsArchived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSender = `-- name: UpdateSender :one
UPDATE sender
SET 
    name = COALESCE($1, name),
    address = COALESCE($2, address),
    postal_code = COALESCE($3, postal_code),
    place = COALESCE($4, place),
    land = COALESCE($5, land),
    kvknumber = COALESCE($6, kvknumber),
    btwnumber = COALESCE($7, btwnumber),
    phone_number = COALESCE($8, phone_number),
    client_number = COALESCE($9, client_number),
    email_address = COALESCE($10, email_address),
    contacts = COALESCE($11::JSONB, contacts),
    updated_at = NOW(),
    is_archived = COALESCE($12, is_archived),
    types = COALESCE($13, types)
WHERE 
    id = $14
RETURNING id, types, name, address, postal_code, place, land, kvknumber, btwnumber, phone_number, client_number, email_address, contacts, invoice_template, is_archived, created_at, updated_at
`

type UpdateSenderParams struct {
	Name         *string `json:"name"`
	Address      *string `json:"address"`
	PostalCode   *string `json:"postal_code"`
	Place        *string `json:"place"`
	Land         *string `json:"land"`
	Kvknumber    *string `json:"kvknumber"`
	Btwnumber    *string `json:"btwnumber"`
	PhoneNumber  *string `json:"phone_number"`
	ClientNumber *string `json:"client_number"`
	EmailAddress *string `json:"email_address"`
	Contacts     []byte  `json:"contacts"`
	IsArchived   *bool   `json:"is_archived"`
	Types        *string `json:"types"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateSender(ctx context.Context, arg UpdateSenderParams) (Sender, error) {
	row := q.db.QueryRow(ctx, updateSender,
		arg.Name,
		arg.Address,
		arg.PostalCode,
		arg.Place,
		arg.Land,
		arg.Kvknumber,
		arg.Btwnumber,
		arg.PhoneNumber,
		arg.ClientNumber,
		arg.EmailAddress,
		arg.Contacts,
		arg.IsArchived,
		arg.Types,
		arg.ID,
	)
	var i Sender
	err := row.Scan(
		&i.ID,
		&i.Types,
		&i.Name,
		&i.Address,
		&i.PostalCode,
		&i.Place,
		&i.Land,
		&i.Kvknumber,
		&i.Btwnumber,
		&i.PhoneNumber,
		&i.ClientNumber,
		&i.EmailAddress,
		&i.Contacts,
		&i.InvoiceTemplate,
		&i.IsArchived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
